    strict namespace {

enum : int
{
    CONST_TID = 99900
};

struct PlayerT
{
    int class;
    int score;
    int team;
    int tid;
    bool ingame;
    bool mouse;
};

PlayerT players[BCSUTILS::MAX_PLAYERS];

Script "ChessFrag" (int type, int arg1, int arg2) EVENT
{
    if(type == GAMEEVENT_PLAYERFRAGS)
    {
        int killerNumber = PlayerNumber();
        int victimNumber = arg1;

        if(killerNumber == victimNumber)
            terminate;

        int victimPoint = CHESS::CLASS::class[players[victimNumber].class].point;

        if(players[killerNumber].class == CHESS::CLASS::CLASS_KING)
        {
            players[killerNumber].score += 1;
            //log(d:players[killerNumber].score);
            if(players[killerNumber].score <= 14)
            {
                if(players[killerNumber].score == 14)
                {
                    SetFont("CW_FONT2");
                    SetHUDSize(1440, 1080, false);
                    HudMessage(s:"Last Weapon!";HUDMSG_FADEOUT, 5, CR_UNTRANSLATED, 720.4, 540.0, 0.5, 1.0);
                }

                ClearActorInventory(GetPlayerTid(killerNumber));
                GiveActorInventory(GetPlayerTid(killerNumber), CHESS::CLASS::gungame[players[killerNumber].score], 1);
            }
            LogDebug(str(killerNumber) + "'s King scored\nGetting Weapon : " + CHESS::CLASS::gungame[players[killerNumber].score]);
        }
        else if(victimPoint == CHESS::CLASS::CONST_KING_POINT)
        {
            players[killerNumber].score += CHESS::CLASS::GetKingPoint(victimNumber);
        }
        else
        {      
            players[killerNumber].score += victimPoint;
        }

        if(victimPoint == CHESS::CLASS::CONST_KING_POINT)
        {
            CHESS::game.score[players[killerNumber].team] += CHESS::CLASS::GetKingPoint(victimNumber);
        }
        else
        {      
            CHESS::game.score[players[killerNumber].team] += victimPoint;
        } 
    }
}

script "ChessRespawn" RESPAWN
{
    Thing_ChangeTID(0, players[PlayerNumber()].tid);
    //log(d:players[PlayerNumber()].tid);
    if(CHESS::gameState >= CHESS::GAMESTATE_OPENING)
    {
        CHESS::CLASS::becomeClass(players[playernumber()].class);
        CHESS::MAP::TeleportToChessBoard();
        CHESS::MAP::ThrustPlayerFromChessBoard(PlayerNumber());
    }
    while(1)
    {
        switch(players[PlayerNumber()].class)
        {
            case CHESS::CLASS::CLASS_PAWN:
                PawnSpecial();
                break;
            case CHESS::CLASS::CLASS_BISHOP:
                BishopSpecial();
                break;
        }
        GiveInventory("Clip", 400);
        GiveInventory("Shell", 400);
        GiveInventory("RocketAmmo", 400);
        GiveInventory("Cell", 400);

        if(CHESS::gameState == CHESS::GAMESTATE_CHECKMATE || ClassifyActor(0) == ACTOR_DEAD)
            break;
        delay(1);
    }
}

function bool IsBlack()
{
	return (PlayerTeam() == 3 || PlayerTeam() == 1);
}

fixed mod(fixed a, fixed b)
{
	while (a > 0.0)
    {
        a -= b;
    }

    return a += b; // replacement for % for now
}


int GetPlayerTid(int pnum)
{
    return pnum + CONST_TID;
}

script "Enter" ENTER
{
    ClearInventory();
    players[PlayerNumber()].ingame = true;
    players[PlayerNumber()].tid = GetPlayerTid(PlayerNumber());
    Thing_ChangeTID(0, players[PlayerNumber()].tid);
    LogDebug("Player " + str(PlayerNumber()) + "'s tid:\nstruct -> " + str(players[PlayerNumber()].tid) + " actual tid -> " + str(ActivatorTid()));

    if(IsBlack())
    {
        players[PlayerNumber()].team = CHESS::TEAM_BLACK;
        Player_SetTeam(1, true);
    }
    else
    {
        players[PlayerNumber()].team = CHESS::TEAM_WHITE;
        Player_SetTeam(0, true);
    }

    if(CHESS::gameState >= CHESS::GAMESTATE_OPENING)
    {
        LogDebug(__SCRIPT__ + " : Player " + str(PlayerNumber()) + " joined midgame. automatically assigning class.");
        players[playernumber()].class = CHESS::GetRemainingClass();
        CHESS::CLASS::becomeClass(players[playernumber()].class, true);
        CHESS::MAP::TeleportToChessBoard();
        CHESS::MAP::ThrustPlayerFromChessBoard(PlayerNumber());
    }

    while(1)
    {
        switch(players[PlayerNumber()].class)
        {
            case CHESS::CLASS::CLASS_PAWN:
                PawnSpecial();
                break;
            case CHESS::CLASS::CLASS_BISHOP:
                BishopSpecial();
                break;
        }
        GiveInventory("Clip", 400);
        GiveInventory("Shell", 400);
        GiveInventory("RocketAmmo", 400);
        GiveInventory("Cell", 400);

        if(CHESS::gameState == CHESS::GAMESTATE_CHECKMATE || ClassifyActor(0) == ACTOR_DEAD)
            break;
        delay(1);
    }

    SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
}

script "Disconnect" (int pnum) DISCONNECT
{
    players[pnum].ingame = false;
}

script "Death" DEATH
{
    BCSUTILS::SetActorAlpha(ActivatorTid(), 0.0);
    PlaySound(ActivatorTid(), "chess_capture", CHAN_AUTO);
    Thing_ChangeTID(0, 0);
}

} 