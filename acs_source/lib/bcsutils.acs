/*
 * This is a patched version of BCSUtils for Zombie Horde.
 * This version is a library rather than a regular file,
 *   and it contains various changes to support DoomerPublish and BCC:
 *     - Library is contained in an anonymous namespace.
 *     - Added ` ` to all public functions.
 *     - Removed `INT_MIN` and `INT_MAX`.
 *	   - `floor`, `ceil` and `round` are now `customFloor`, `customCeil` and `customRound`.
 */


/*
MIT License

Copyright (c) 2016-2017 Alexander Korshun and the ACSUtils contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

ACSUtils uses code from ACS-X:	
	
	Copyright Ben Moir 2016
	Distributed under the Boost Software License, Version 1.0.

	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/

//#library "bcsutils"
#nocompact

//#import "zcommon.bcs"

// ZDoom does not allow to use more than 128 map variables in a single library.
// To reduce the amount of map variables ACSUtils use, all simple globals
// have been put into an array.
strict namespace BCSUTILS {

internal enum : int { ACSUTILS_VERSION_MAJOR = 1 };
internal enum : int { ACSUTILS_VERSION_MINOR = 8 };
internal enum : int { ACSUTILS_VERSION_PATCH = 2 };

 
str ACSUtilsVersion(void)
{
	return StrParam(
		d:ACSUTILS_VERSION_MAJOR, s:".",
		d:ACSUTILS_VERSION_MINOR, s:".",
		d:ACSUTILS_VERSION_PATCH
	);
}

// Multiple return values.
raw r1, r2, r3, r4, r5, r6, r7, r8;

internal enum : fixed { HUDTIC = 0.03 };
internal enum : fixed { HUD_STAYTIME_FOREVER = (fixed)(-1) };

internal enum : int { HUD_BLENDSTYLE_NORMAL = 0 };
internal enum : int { HUD_BLENDSTYLE_ADDITIVE = 1 };

internal enum : int { HUD_ALIGN_CENTER = 0 };
internal enum : int { HUD_ALIGN_LEFT = 1 };
internal enum : int { HUD_ALIGN_RIGHT = 2 };
internal enum : int { HUD_ALIGN_TOP = 1 };
internal enum : int { HUD_ALIGN_BOTTOM = 2 };

internal enum : int { HUD_PROJECTION_AUTO = 0 };
internal enum : int { HUD_PROJECTION_3D = 1 };
internal enum : int { HUD_PROJECTION_YSHEARING = 2 };

raw ACSUtils_Ints[55] = {
	240.0, // CursorY
	false, // R_TextColorIsString
	480.0, // CursorAreaHeight
	CR_UNTRANSLATED, // R_TextColor
	-1, // CachedPort
	0.0, // R_AppearTime
	HUD_STAYTIME_FOREVER, // R_StayTime
	1.0, // CursorSpeedY
	false, // CursorWrapX
	0.0, // R3D_CameraY
	false, // R_TextWordWrap
	0.0, // R3D_CameraPitch
	0.0, // R3D_2DOffsetX
	HUD_ALIGN_CENTER, // R_AlignX
	0, // R_RotatedX
	0.0, // R3D_Y
	320.0, // CursorPrevX
	HUD_PROJECTION_AUTO, // R3D_ProjectionMode
	0.0, // R_Y
	0.0, // R3D_CameraX
	0.0, // R3D_Z
	0.0, // R3D_2DOffsetY
	0, // R_RotatedZ
	640.0, // R_BaseWidth
	true, // R_ShowIn3DView
	1.0, // R_Alpha
	false, // R_CenterText
	HUDMSG_LAYER_OVERHUD, // R_Layer
	0.0, // R3D_CameraAngle
	0, // CursorMotionX
	1.0, // R_IScaleX
	1.0, // CursorSpeedX
	0.0, // R3D_X
	false, // R_LogMessage
	true, // R_ShowOnOverlayAutomap
	320.0, // CursorX
	0, // HudStateStackTop
	false, // R_ShowToEveryone
	0, // CursorMotionY
	HUD_BLENDSTYLE_NORMAL, // R_BlendStyle
	0.0, // R3D_CameraZ
	0.0, // R_X
	true, // R3D_AutoDistanceScale
	false, // CursorWrapY
	0, // R_RotatedY
	false, // R_ExcludeStatusBar
	480.0, // R_BaseHeight
	240.0, // CursorPrevY
	0.0, // R_DisappearTime
	HUD_ALIGN_CENTER, // R_AlignY
	true, // R_ShowOnFullAutomap
	1.0, // R_IScaleY
	false, // R_Is3DPoint
	640.0, // CursorAreaWidth
	false, // R_TextTypeOn
};

str ACSUtils_Strings[1] = {
	"SMALLFONT", // R_TextFont
};

internal enum : int { ACSUTILS_ERROR_PROGRAM = 0 };
internal enum : int { ACSUTILS_ERROR_MAPPING = 1 };
internal enum : int { ACSUTILS_ERROR_LIMIT = 2 };

void ACSUtils_ProgramError(str message)
{
	ACSUtils_ErrorHandler(ACSUTILS_ERROR_PROGRAM, message);
}

void ACSUtils_LimitError(str message)
{
	ACSUtils_ErrorHandler(ACSUTILS_ERROR_LIMIT, message);
}

void ACSUtils_ErrorHandler(int type, str message)
{
	str text = "";
	if (IsServer() != IsClient())
	{
		if (IsServer())
			text = "[\cgserverside\c-] ";
		else
			text = "[\cdclientside\c-] ";
	}
	
	text = StrParam(s:text, d:Timer(), s:" ACSUtils error: ", s:message);
	if (!IsClient())
		Log(s:text);

	if (GetCVar("acsutils_noerrors"))
		return;

	printbold(s:text);
}
internal enum : fixed { FIXED_MAX = (fixed)(0x7fffffff) };
internal enum : fixed { FIXED_MIN = (fixed)(0x80000000) };
internal enum : int { USHORT_MAX = 65535 };
internal enum : int { SHORT_MAX = 32767 };
internal enum : int { SHORT_MIN = -32768 };
internal enum : int { UBYTE_MAX = 255 };
internal enum : int { SBYTE_MAX = 127 };
internal enum : int { SBYTE_MIN = -128 };

internal enum : fixed { PI = 3.1415926535897932384626433832795 };
internal enum : fixed { TAU = 6.2831853071795864769252867665590 };
internal enum : fixed { SQRT_2 = 1.41421356237 };
internal enum : fixed { MATH_E = 2.7182818284590452353602874713526624977572470937 };
internal enum : fixed { LOG2_E = 1.44269504089 };
internal enum : fixed { LOG2_10 = 3.32192809489 };

// Generic functions.

 
raw min(raw a, raw b)
{
	if (a < b)
		return a;
	return b;
}

 
raw max(raw a, raw b)
{
	if (a > b)
		return a;
	return b;
}

 
int clamp(raw x, raw a, raw b)
{
	if (x > b)
		return b;
	if (x < a)
		return a;
	return x;
}	

 
int sgn(raw x)
{
	if (x > 0)
		return 1;
	if (x < 0)
		return -1;
	return 0;
}

 
raw abs(raw x)
{
	if (x > 0)
		return x;
	return -x;
}

// From commonFuncs.h by Ijon Tichy.
 
raw middle(raw x, raw y, raw z)
{
    if ((x < z) && (y < z)) { return max(x, y); }
    return max(min(x, y), z);
}

 
int cmp(raw a, raw b)
{
	if (a > b)
		return 1;
	if (a < b)
		return -1;
	return 0;
}

 
raw mod(raw a, raw b)
{
	if (a < 0)
	{
		int rem = a % b;
		if (rem != 0)
			return b + (a % b);
		return 0;
	}
	
	return a % b;
}

 
raw cond(bool x, raw whentrue, raw whenfalse)
{
	if (x)
		return whentrue;
	return whenfalse;
}

 
raw condTrue(raw x, raw whentrue)
{
	if (x)
		return whentrue;
	return x;
}

 
raw condFalse(raw x, raw whenfalse)
{
	if (x)
		return x;
	return whenfalse;
}

// Rounding.

 
fixed fract(fixed x)
{
	return x - trunc(x);
}

 
fixed trunc(fixed x)
{
	if (x > 0.0)
		return customFloor(x);
	return customCeil(x);
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */
 
fixed customFloor(fixed x)
{
	return (fixed)((int)(x) & 0xffff0000);
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */
 
fixed customCeil(fixed x)
{
	return (fixed)(((int)(x) - 1) & 0xffff0000) + 1.0;
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */
 
fixed customRound(fixed x)
{
	return (fixed)((int)(x + 0.5) & 0xffff0000);
}

 
int itrunc(fixed x)
{
	if (x > 0.0)
		return ifloor(x);
	return iceil(x);
}

 
int ifloor(fixed x)
{
	return (int)(x)>>16;
}

 
int iceil(fixed x)
{
	return ((int)(x) - 1 >> 16) + 1;
}

 
int iround(fixed x)
{
	return (int)(x + 0.5) >> 16;
}


// Numerical algorithms.

 
fixed AngleDiff(fixed a, fixed b)
{
	a = mod(a, 1.0);
	b = mod(b, 1.0);
	fixed diff = b - a;

	if (diff > 0.5)
		return diff - 1.0;
	else if (diff < -0.5)
		return diff + 1.0;
	return diff;
}


 
int ipow(int x, int y)
{
    int n = 1;
    while (y-- > 0)
		n *= x;
    return n;
}

 
fixed fpow(fixed x_, fixed y_)
{
	raw x = x_;
	raw y = y_;
	raw n = 1.0;
	if (y > 0)
	{
		while (y-- > 0)
			n = FixedMul(n, x);
		return n;
	}
	
	while (y++ < 0)
		n = FixedDiv(n, x);
	return n;
}

 
fixed lerp(fixed a, fixed b, fixed alpha)
{
	return FixedMul(a, 1.0 - alpha) + FixedMul(b, alpha);
}

// From commonFuncs.h by Ijon Tichy.
 
raw gcf(raw a, raw b)
{
    int c;
    while (1)
    {
        if (b == 0) { return a; }
        c = a % b;
        a = b;
        b = c;
    }
    
    return -1;
}

// By TechnoDoomed1
// fixed IntDiv(int a, int b)
 
fixed IntDiv (int a_, int b_) {
    raw a = a_;
	raw b = b_;
	raw quotient = 0, current_fraction = 1.0;

    // Only works when the ratio is less than 32767 = 2^15 - 1.
    // Otherwise return 0.

    if ((abs(a) / abs(b)) > 32767) {
        return 0.0;
    }

    // Performs the same algorithm as hand division, but working with powers of 2 instead of 10.
    // This is done until we reach the maximum allowed precision, which is 1 (=2^-16 in fixed point).

    while (current_fraction > 1) {
        quotient += (a / b) * current_fraction;
        a = (a % b) * 2;
        current_fraction /= 2;
    }

    return (fixed)(quotient);
}

// raw, raw swap(raw a, raw b)
 
void swap(raw a, raw b)
{
	r1 = b;
	r2 = a;
}

// Bit math.

 
int getbit(int x, int n)
{
	return x & (1 << n);
}

 
int clrbit(int p, int n)
{
	return p & ~(1 << n);
}

 
int setbit(int p, int n)
{
	return p | ~(1 << n);
}

 
int tglbit(int p, int n)
{
	return p ^ (1 << n);
}

 
bool notflag(int flags, int flag)
{
	return !(flags & flag);
}

 
bool randbool(void)
{
	return (bool)(Random(0, 1));
}

 
int randint(void)
{
	return Random(INT_MIN, INT_MAX);
}

// From commonFuncs.h by Ijon Tichy.
 
int randsign(void)
{
	return 2 * Random(0, 1) - 1;
}

 
raw RandomPick2(raw v0, raw v1)
{
	if (Random(0, 1))
		return v0;
	return v1;
}

 
raw RandomPick3(raw v0, raw v1, raw v2)
{
	int x = Random(0, 2);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	}

	return v2;
}

 
raw RandomPick4(raw v0, raw v1, raw v2, raw v3)
{
	int x = Random(0, 3);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	}

	return v3;
}

 
raw RandomPick5(raw v0, raw v1, raw v2, raw v3, raw v4)
{
	int x = Random(0, 4);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	}

	return v4;
}

 
raw RandomPick6(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5)
{
	int x = Random(0, 5);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	}

	return v5;
}

 
raw RandomPick7(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6)
{
	int x = Random(0, 6);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	}

	return v6;
}

 
raw RandomPick8(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6, raw v7)
{
	int x = Random(0, 7);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	case 6: return v6;
	}

	return v7;
}

 
int npo2(int v)
{
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

 
int getNumDigits(int base, int number)
{
	int digits = 0;
	while (number)
	{
		digits++;
		number /= base;
	}
	return digits;
}

 
int flag2index(int x)
{
	return getNumDigits(2, x) - 1;
}


// Logarithms.

// All logaritm functions written by TechnoDoomed1 unless stated otherwise

 
fixed log2 (fixed x_) {
    raw x = x_;
	
	// We calculate the integral and decimal parts of the bit logarithm of x.
    raw integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number in the range [1, 2).
    // If the number is on the range (0, 1) then we multiply by 2 until we reach a number in the range [1, 2).
    while (x < 1.0) {
        -- integer_part;
        x *= 2;
    }
    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a fixed-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    raw current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the fixed-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}

 
fixed ilog2 (int x_) {
    raw x = x_;
	
	// We calculate the integral and decimal parts of the bit logarithm of x.
    raw integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number lower than 2.
    // We lose precision by not keeping the fractional part until that part fits perfectly in a fixed number variable.
    while (x >= 32768) {
        ++ integer_part;
        x /= 2;
    }

    x <<= 16;

    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a fixed-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    raw current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the fixed-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}


 
fixed ln (fixed x) {
    // This calculates the natural logarithm of a number using the property that:   ln(x) = log_2(x) / log_2(e)
    // This is done because calculating the log_2 of a number is far easier, specially with fixed-point arithmetics. 

    return FixedDiv(log2(x), LOG2_E);
}

// By Korshun.
 
fixed iln (int x) {
	return FixedDiv(ilog2(x), LOG2_E);
}

// By Korshun.
 
fixed log10 (fixed x) {
	return FixedDiv(log2(x), LOG2_10);
}

// By Korshun.
 
fixed ilog10 (int x) {
	return FixedDiv(ilog2(x), LOG2_10);
}

 
fixed logb (fixed x, fixed base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(log2(x), log2(base));
   
    return 0.0;
}

// By Korshun.
 
fixed ilogb (int x, fixed base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(ilog2(x), log2(base));
   
    return 0.0;
}

// Trigonometry.

 
fixed tan(fixed x)
{
	return FixedDiv(sin(x), cos(x));
}

 
fixed cot(fixed x)
{
	return FixedDiv(cos(x), sin(x));
}

 
fixed sec(fixed x)
{
	return FixedDiv(1.0, sin(x));
}

 
fixed cosec(fixed x)
{
	return FixedDiv(1.0, cos(x));
}

 
fixed atan(fixed x)
{
    return VectorAngle(1.0, x);
}

 
fixed asin(fixed x)
{
	return atan(FixedDiv(x, FixedSqrt(1.0 - FixedMul(x, x))));
}

 
fixed acos(fixed x)
{
	return (fixed)((int)(2) * (int)(atan(FixedSqrt(FixedDiv(1.0 - x, 1.0 + x)))));
}

 
fixed acot(fixed x)
{
 	return 0.25 - atan(x);
}

 
fixed asec(fixed x)
{
	return acos(FixedDiv(1.0, x));
}

 
fixed acosec(fixed x)
{
	 return asin(FixedDiv(1.0, x));
}

// Vectors.

// fixed, fixed RotateVector(fixed x, fixed y, fixed angle);
 
void RotateVector(fixed x, fixed y, fixed angle)
{
	// Rotate around Z axis.
	fixed s = sin(angle);
	fixed c = cos(angle);
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}

// fixed, fixed RotateVectorCS(fixed x, fixed y, fixed c, fixed s);
 
void RotateVectorCS(fixed x, fixed y, fixed c, fixed s)
{
	// Rotate around Z axis.
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}

// fixed, fixed RotatePoint(fixed x, fixed y, fixed originX, fixed originY, fixed angle)
 
void RotatePoint(fixed x, fixed y, fixed originX, fixed originY, fixed angle)
{
	x -= originX;
	y -= originY;
	RotateVector(x, y, angle);
	r1 += originX;
	r2 += originY;
}

// fixed, fixed VectorToAngles(fixed x, fixed y, fixed z)
 
void VectorToAngles(fixed x, fixed y, fixed z)
{
	fixed xy = VectorLength(x, y);
		
	r1 = VectorAngle(x, y);
	r2 = VectorAngle(xy, z);
}

// fixed, fixed, fixed AnglesToVector(fixed angle, fixed pitch)
 
void AnglesToVector(fixed angle, fixed pitch)
{
	fixed cos_pitch = cos(pitch);
	r1 = FixedMul(cos_pitch, cos(angle));
    r2 = FixedMul(cos_pitch, sin(angle));
    r3 = sin(pitch);
}

 
fixed VectorLength3D(fixed x, fixed y, fixed z)
{
	 return VectorLength(VectorLength(x, y), z);
}

 
fixed SqVectorLength(fixed x, fixed y)
{
	return FixedMul(x, x) + FixedMul(y, y);
}

 
fixed SqVectorLength3D(fixed x, fixed y, fixed z)
{
	return FixedMul(x, x) + FixedMul(y, y) + FixedMul(z, z);
}

 
fixed dot2(fixed x1, fixed y1, fixed x2, fixed y2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2);
}

 
fixed dot3(fixed x1, fixed y1, fixed z1, fixed x2, fixed y2, fixed z2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2) + FixedMul(z1, z2);
}

 
void normalize2d(fixed x, fixed y)
{
	fixed l = VectorLength(x, y);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
}

 
void normalize3d(fixed x, fixed y, fixed z)
{
	fixed l = VectorLength3D(x, y, z);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
	r3 = FixedDiv(z, l);
}

internal enum : int { COLORCODE = 28 };

internal enum : int { ACSUTILS_ISALNUM = 1<<0 };
internal enum : int { ACSUTILS_ISALPHA = 1<<1 };
internal enum : int { ACSUTILS_ISBLANK = 1<<2 };
internal enum : int { ACSUTILS_ISCNTRL = 1<<3 };
internal enum : int { ACSUTILS_ISDIGIT = 1<<4 };
internal enum : int { ACSUTILS_ISGRAPH = 1<<5 };
internal enum : int { ACSUTILS_ISLOWER = 1<<6 };
internal enum : int { ACSUTILS_ISPRINT = 1<<7 };
internal enum : int { ACSUTILS_ISPUNCT = 1<<8 };
internal enum : int { ACSUTILS_ISSPACE = 1<<9 };
internal enum : int { ACSUTILS_ISUPPER = 1<<10 };
internal enum : int { ACSUTILS_ISXDIGIT = 1<<11 };


int ACSUtils_AsciiTypes[128] =
{
ACSUTILS_ISCNTRL, // NUL
ACSUTILS_ISCNTRL, // SOH
ACSUTILS_ISCNTRL, // STX
ACSUTILS_ISCNTRL, // ETX
ACSUTILS_ISCNTRL, // EOT
ACSUTILS_ISCNTRL, // ENQ
ACSUTILS_ISCNTRL, // ACK
ACSUTILS_ISCNTRL, // BEL
ACSUTILS_ISCNTRL, // BS
ACSUTILS_ISBLANK | ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // TAB
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // LF
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // VT
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // FF
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // CR
ACSUTILS_ISCNTRL, // SO
ACSUTILS_ISCNTRL, // SI
ACSUTILS_ISCNTRL, // DLE
ACSUTILS_ISCNTRL, // DC1
ACSUTILS_ISCNTRL, // DC2
ACSUTILS_ISCNTRL, // DC3
ACSUTILS_ISCNTRL, // DC4
ACSUTILS_ISCNTRL, // NAK
ACSUTILS_ISCNTRL, // SYN
ACSUTILS_ISCNTRL, // ETB
ACSUTILS_ISCNTRL, // CAN
ACSUTILS_ISCNTRL, // EM
ACSUTILS_ISCNTRL, // SUB
ACSUTILS_ISCNTRL, // ESC
ACSUTILS_ISCNTRL, // FS (COLORCODE)
ACSUTILS_ISCNTRL, // GS
ACSUTILS_ISCNTRL, // RS
ACSUTILS_ISCNTRL, // US
ACSUTILS_ISBLANK | ACSUTILS_ISPRINT | ACSUTILS_ISSPACE, // Space
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // !
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // "
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // #
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // $
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // %
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // &
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // '
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // (
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // )
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // *
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // +
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ,
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // -
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // .
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // /
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 0
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 1
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 2
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 3
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 4
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 5
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 6
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 7
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 8
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 9
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // :
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ;
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // <
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // =
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // >
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ?
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // @
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // A
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // B
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // C
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // D
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // E
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // F
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // G
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // H
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // I
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // J
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // K
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // L
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // M
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // N
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // O
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // P
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Q
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // R
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // S
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // T
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // U
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // V
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // W
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // X
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Y
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Z
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // [
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // \
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ]
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ^
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // _
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // `
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // a
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // b
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // c
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // d
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // e
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // f
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // g
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // h
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // i
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // j
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // k
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // l
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // m
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // n
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // o
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // p
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // q
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // r
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // s
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // t
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // u
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // v
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // w
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // x
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // y
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // z
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // {
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // |
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // }
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ~
ACSUTILS_ISCNTRL, // DEL
};

 
bool isalnum(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISALNUM);
}

 
bool isalpha(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISALPHA);
}

 
bool isblank(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISBLANK);
}

 
bool iscntrl(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISCNTRL);
}

 
bool isdigit(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISDIGIT);
}

 
bool isgraph(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISGRAPH);
}

 
bool islower(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISLOWER);
}

 
bool isprint(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISPRINT);
}

 
bool ispunct(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISPUNCT);
}

 
bool isspace(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISSPACE);
}

 
bool isupper(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISUPPER);
}

 
bool isxdigit(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISXDIGIT);
}

 
bool isascii(int c)
{
	return c >= 0 && c < 128;
}

 
int toupper(int c)
{
	if (islower(c))
		return c - 32;
	return c;
}

 
int tolower(int c)
{
	if (isupper(c))
		return c + 32;
	return c;
}


// String versions
 
bool StrIsAlNum(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isalnum(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsAlpha(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isalpha(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsBlank(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isblank(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsCntrl(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!iscntrl(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsDigit(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isdigit(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsGraph(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isgraph(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsLower(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!islower(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsPrint(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isprint(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsSpace(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isspace(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsUpper(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isupper(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsXDigit(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isxdigit(GetChar(s, i)))
			return false;
			
	return true;
}

 
bool StrIsAscii(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
	{
		int char = GetChar(s, i);
		if (char < 0 || char > 127)
			return false;
	}
	return true;
}

// Case conversion.

 
str StrToLower(str s)
{
	str result = "";
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:tolower(GetChar(s, i)));
		
	return result;
}

 
str StrToUpper(str s)
{
	str result = "";
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:toupper(GetChar(s, i)));
		
	return result;
}

// Basic
 
bool StrIsEmpty(str s)
{
	if (!GetChar(s, 0))
		return true;
	return false;
}


// StrAdd
 
str StrAdd(str a, str b)
{
	return StrParam(s:a, s:b);
}

 
str StrAddInt(str a, int b)
{
	return StrParam(s:a, d:b);
}

 
str StrAddChar(str a, int b)
{
	return StrParam(s:a, c:b);
}

 
str StrAddFixed(str a, fixed b)
{
	return StrParam(s:a, f:b);
}

// StrEquals
 
bool StrEquals(str a, str b)
{
    return StrCmp(a, b) == 0;
}	

 
bool StrIEquals(str a, str b)
{
	return StrICmp(a, b) == 0;
}

 
bool StrEqualsAt(str s, int where, str what)
{
	int len = StrLen(what);
	if (where + len > StrLen(s))
		return false;
	
	return StrEquals(StrMid(s, where, len), what);
}

 
bool StrIEqualsAt(str s, int where, str what)
{
	int len = StrLen(what);
	if (where + len > StrLen(s))
		return false;
	
	return StrIEquals(StrMid(s, where, len), what);
}

 
bool StrStartsWith(str s, str sub)
{
	return StrEqualsAt(s, 0, sub);
}

 
bool StrStartsWithI(str s, str sub)
{
	return StrIEqualsAt(s, 0, sub);
}

 
bool StrEndsWith(str s, str what)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);

	if (len1 < len2)
		return false;
	return StrEqualsAt(s, len1 - len2, what);
}

 
bool StrEndsWithI(str s, str what)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);

	if (len1 < len2)
		return false;
	return StrIEqualsAt(s, len1 - len2, what);
}

// StrFind
 
int StrFind(str s, str what)
{
	return StrFindFrom(s, what, 0);
}

 
int StrFindI(str s, str what)
{
	return StrFindFromI(s, what, 0);
}

 
int StrRFind(str s, str what)
{
	return StrRFindFrom(s, what, StrLen(s) - 1);
}

 
int StrRFindI(str s, str what)
{
	return StrRFindFromI(s, what, StrLen(s) - 1);
}

 
int StrFindFrom(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i <= len; i++)
	{
		if (StrEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

 
int StrFindFromI(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i <= len; i++)
	{
		if (StrIEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

 
int StrRFindFrom(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i >= 0; i--)
	{
		if (StrEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

 
int StrRFindFromI(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i >= 0; i--)
	{
		if (StrIEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

// StrRemove
 
str StrRemove(str s, str what)
{
	return StrReplace(s, what, "");
}

 
str StrRemoveI(str s, str what)
{
	return StrReplaceI(s, what, "");
}

 
str StrRemoveFirst(str s, str what)
{
	return StrRemoveFirstFrom(s, what, 0);
}

 
str StrRemoveFirstI(str s, str what)
{
	return StrRemoveFirstFromI(s, what, 0);
}

 
str StrRemoveLast(str s, str what)
{
	return StrRemoveLastFrom(s, what, StrLen(s) - 1);
}

 
str StrRemoveLastI(str s, str what)
{
	return StrRemoveLastFromI(s, what, StrLen(s) - 1);
}

 
str StrRemoveFirstFrom(str s, str what, int start)
{
	int pos = StrFindFrom(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

 
str StrRemoveFirstFromI(str s, str what, int start)
{
	int pos = StrFindFromI(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

 
str StrRemoveLastFrom(str s, str what, int start)
{
	int pos = StrRFindFrom(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

 
str StrRemoveLastFromI(str s, str what, int start)
{
	int pos = StrRFindFromI(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

// StrReplace
 
str StrReplace(str s, str what, str with)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);
	int start = 0;
	int end = 0;
	str result = "";

	while (true)
	{
		end = StrFindFrom(s, what, start);
		if (end == -1)
		{
			result = StrParam(s:result, s:StrSlice(s, start, end));
			break;
		}

		result = StrParam(s:result, s:StrSlice(s, start, end), s:with);
		start = end + len2;
	}
	
	return result;
}

 
str StrReplaceI(str s, str what, str with)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);
	int start = 0;
	int end = 0;
	str result = "";

	while (true)
	{
		end = StrFindFromI(s, what, start);
		if (end == -1)
		{
			result = StrParam(s:result, s:StrSlice(s, start, end));
			break;
		}

		result = StrParam(s:result, s:StrSlice(s, start, end), s:with);
		start = end + len2;
	}
	
	return result;
}

 
str StrReplaceFirst(str s, str what, str with)
{
	return StrReplaceFirstFrom(s, what, with, 0);
}

 
str StrReplaceFirstI(str s, str what, str with)
{
	return StrReplaceFirstFromI(s, what, with, 0);
}

 
str StrReplaceLast(str s, str what, str with)
{
	return StrReplaceLastFrom(s, what, with, StrLen(s) - 1);
}

 
str StrReplaceLastI(str s, str what, str with)
{
	return StrReplaceLastFromI(s, what, with, StrLen(s) - 1);
}

 
str StrReplaceFirstFrom(str s, str what, str with, int start)
{
	int pos = StrFind(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

 
str StrReplaceFirstFromI(str s, str what, str with, int start)
{
	int pos = StrFindI(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

 
str StrReplaceLastFrom(str s, str what, str with, int start)
{
	int pos = StrRFind(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

 
str StrReplaceLastFromI(str s, str what, str with, int start)
{
	int pos = StrRFindI(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

// Misc
 
str LeftPad(str s, int c, int size)
{
	int len = StrLen(s);
	if (len >= size)
		return s;
		
	int diff = size - len;
	str pad = "";
	for (int i = 0; i < diff; i++)
		pad = StrParam(s:pad, c:c);
		
	return StrParam(s:pad, s:s);
}

 
str RightPad(str s, int c, int size)
{
	int len = StrLen(s);
	if (len >= size)
		return s;
		
	int diff = size - len;
	str pad = "";
	for (int i = 0; i < diff; i++)
		pad = StrParam(s:pad, c:c);
		
	return StrParam(s:s, s:pad);
}

 
str StrCapitalize(str s)
{
	if (StrLen(s) == 0)
		return "";

	str result = StrParam(c:toupper(GetChar(s, 0)));
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:tolower(GetChar(s, i)));

	return result;
}

 
bool StrContains(str s, str what)
{
	return StrFind(s, what) >= 0;
}

 
bool StrContainsI(str s, str what)
{
	return StrFindI(s, what) >= 0;
}

 
str StrCut(str s, int start, int length)
{
	return StrParam(s:StrLeft(s, start), s:StrRightFrom(s, start + length));
}

 
str StrCutRange(str s, int start, int end)
{
	return StrParam(s:StrLeft(s, start), s:StrRightFrom(s, end));
}

 
str StrInsert(str s, int where, str what)
{
	return StrParam(s:StrLeft(s, where), s:what, s:StrRightFrom(s, where));
}

 
str StrSlice(str s, int start, int end)
{
	return StrMid(s, start, end - start);
}

 
void StrSplit(str s, str separator)
{
	int pos = StrFind(s, separator);
	if (pos != -1)
	{
		r1 = StrLeft(s, pos);
		r2 = StrRightFrom(s, pos + StrLen(separator));
	}
	else
	{
		r1 = s;
		r2 = "";
	}
}

 
void StrSplitI(str s, str separator)
{
	int pos = StrFindI(s, separator);
	if (pos != -1)
	{
		r1 = StrLeft(s, pos);
		r2 = StrRightFrom(s, pos + StrLen(separator));
	}
	else
	{
		r1 = s;
		r2 = "";
	}
}

 
str StrRightFrom(str s, int from)
{
	return StrRight(s, StrLen(s) - from);
}

 
str StrRepeat(str s, int n)
{
	str result = "";
	for (int i = 0; i < n; i++)
		result = StrAdd(result, s);
	return result;
}

 
str StrReverse(str s)
{
	str tempstr = "";
	for(int i = StrLen(s)-1; i >= 0; i--)
		tempstr = StrParam(s:tempstr, c:GetChar(s, i));
	return tempstr;
}

// Color codes.
 
bool IsColorCodeChar(int c)
{
	return (c >= 'a' && c <= 'v')
		|| c == '-'
		|| c == '+'
		|| c == '*'
		|| c == '!';
}

 
int SkipColorCodeAt(str s, int i)
{
	if (GetChar(s, i) == COLORCODE)
	{
		i++;
	}
	else
	{
		return i;
	}
	
	if (GetChar(s, i) == '[')
	{
		int len = StrLen(s);
		for (; i < len; i++)
		{
			if (GetChar(s, i) == ']')
			{
				i++;
				break;
			}
		}
	}
	else if (IsColorCodeChar(GetChar(s, i)))
	{
		return i + 1;
	}
	
	return i;
}
	
 
str GetColorCodeAt(str s, int i)
{
	return StrSlice(s, i, SkipColorCodeAt(s, i));
}
	
 
bool HasColorCodes(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
	{
		if (GetChar(s, i) == COLORCODE)
			i += 1;
		else
			continue;
			
		int c = GetChar(s, i);
		if (c == '[' || IsColorCodeChar(c))
			return true;
	}
	return false;
}

 
str StripColorCodes(str s)
{
	str result = "";
	for (int i = 0; i < StrLen(s); i++)
	{
		i = SkipColorCodeAt(s, i);
		result = StrParam(s:result, c:GetChar(s, i));
	}

	return result;
}

enum : int { MAX_PLAYERS = 64 };
internal enum : int { MAX_PLAYERS_ZDOOM = 8 };
internal enum : int { TEAM_NONE = 255 };

// Inventory functions.

 
void GiveMaxInventory(str item)
{
	GiveInventory(item, INT_MAX);
}

 
void GiveMaxActorInventory(int tid, str item)
{
	GiveActorInventory(tid, item, INT_MAX);
}

 
void TakeMaxInventory(str item)
{
	TakeInventory(item, INT_MAX);
}

 
void TakeMaxActorInventory(int tid, str item)
{
	TakeActorInventory(tid, item, INT_MAX);
}

 
void SetInventory(str item, int amount)
{
	int diff = amount - CheckInventory(item);
	if (diff > 0)
		GiveInventory(item, diff);
	else if (diff < 0)
		TakeInventory(item, -diff);
}

 
void SetActorInventory(int tid, str item, int amount)
{
	int diff = amount - CheckActorInventory(tid, item);
	if (diff > 0)
		GiveActorInventory(tid, item, diff);
	else if (diff < 0)
		TakeActorInventory(tid, item, -diff);
}

 
void ToggleInventory(str item)
{
	if (CheckInventory(item) > 0)
		SetInventory(item, 0);
	else
		SetInventory(item, 1);
}

 
void ToggleActorInventory(int tid, str item)
{
	if (CheckActorInventory(tid, item) > 0)
		SetActorInventory(tid, item, 0);
	else
		SetActorInventory(tid, item, 1);
}


// CVar functions.

 
fixed a_GetCVarFixed(str name)
{
	str value = GetCVarString(name);
	if ((int)(value) != 0)
		return atof(GetCVarString(name));
	return 0.0;
}

 
fixed a_GetUserCVarFixed(int player, str name)
{
	str value = GetUserCVarString(player, name);
	if ((int)(value) != 0)
		return atof(GetUserCVarString(player, name));
	return 0.0;
}


// Screen info functions.

 
bool StatusBarVisible(void)
{
	return GetCVar("screenblocks") <= 10;
}


// HudMessage functions

 
void ClearHudMessage(int id)
{
	HudMessage(s:""; HUDMSG_PLAIN, id, 0, 0.0, 0.0, 0.0, 0.0);
}

 
void ClearHudMessageBold(int id)
{
	HudMessageBold(s:""; HUDMSG_PLAIN, id, 0, 0.0, 0.0, 0.0, 0.0);
}


// Actor information functions

 
str ActivatorName(void)
{
	return StrParam(n:0);
}

script "ACSUtils_GetActorName" (int tid)
{
	SetActivator(tid);
	SetResultValue((int)(StrParam(n:0)));
}

// todo Verify this still works with the added cast.
 
str GetActorName(int tid)
{
	return (str)ACS_NamedExecuteWithResult("ACSUtils_GetActorName", tid);
}

 
bool IsAlive(void)
{
	if (IsPlayer())
		if (!PlayerInGame(PlayerNumber()))
			return false;
	return GetActorProperty(0, APROP_HEALTH) > 0;
}

 
bool ActorIsAlive(int tid)
{
	if (tid == 0 && IsPlayer())
		if (!PlayerInGame(PlayerNumber()))
			return false;
	return GetActorProperty(tid, APROP_HEALTH) > 0;
}

 
bool ActorExists(int tid)
{
	if (tid != 0)
		return ClassifyActor(tid) != ACTOR_NONE;
	return notflag(ClassifyActor(tid), ACTOR_WORLD);
}

// Actor math functions.

 
fixed ActorDistance(int tid1, int tid2)
{
	return VectorLength3D(GetActorX(tid2) - GetActorX(tid1),
	                      GetActorY(tid2) - GetActorY(tid1),
	                      GetActorZ(tid2) - GetActorZ(tid1));
}

 
fixed ActorDistance2D(int tid1, int tid2)
{
	return VectorLength(GetActorX(tid2) - GetActorX(tid1),
	                    GetActorY(tid2) - GetActorY(tid1));
}

 
fixed GetActorVelocity(int tid)
{
	return VectorLength3D(GetActorVelX(tid), GetActorVelY(tid), GetActorVelZ(tid));
}

 
fixed GetActorXYVelocity(int tid)
{
	return VectorLength(GetActorVelX(tid), GetActorVelY(tid));
}

 
fixed GetActorVelocityXY(int tid)
{
	return VectorLength(GetActorVelX(tid), GetActorVelY(tid));
}

// Actor utility functions.

 
bool HasRoomFor(str classname, fixed x, fixed y, fixed z)
{
	int tid = UniqueTid();
	if (!Spawn(classname, x, y, z, tid))
		return false;
	Thing_Remove(tid);
	return true;
}

 
void LookAtPoint(int tid, fixed x, fixed y, fixed z)
{ 	
	x -= GetActorX(tid);
	y -= GetActorY(tid);
	z -= GetActorZ(tid) + GetActorViewHeight(tid);

	VectorToAngles(x, y, z);
	fixed angle = r1;
	fixed pitch = r2;

	SetActorAngle(tid, angle);
	SetActorPitch(tid, -pitch);
}

 
void LookAt(int tid, int target)
{
	fixed x = GetActorX(target);
	fixed y = GetActorY(target);
	fixed z = GetActorZ(target) + GetActorViewHeight(target);
	LookAtPoint(tid, x, y, z);
}


// ChangeFlag

// Implementation from ACS-X.

 
str ACSUtils_ChangeFlagName(str flag, bool value)
{
	return StrParam(s:"ACSUtils_CF_", s:flag, s:"_", d:(int)(!!value));
}

 
void ChangeFlag(str flag, bool value)
{
	GiveInventory(ACSUtils_ChangeFlagName(flag, value), 1);
}

 
void ChangeActorFlag(int tid, str flag, bool value)
{
	GiveActorInventory(tid, ACSUtils_ChangeFlagName(flag, value), 1);
}


// Mapping functions.

// From ZDoom wiki.
 
int SyncSpeed(int newdistance, int syncdistance, int syncspd)
{
	fixed t = fixeddiv((fixed)(syncdistance<<16), (fixed)(syncspd<<16));
	fixed r = fixeddiv((fixed)(newdistance<<16), t);
	return (int)(r)>>16;
}
//===========================
// INTEGER PACKING
//===========================

// Pack unsigned 8-bit values. ========================================
 
int PackBytes(int a, int b, int c, int d)
{
	return (a<<24) | (b<<16) | (c<<8) | d;
}
 
int UnpackByte1(int x) { return (x>>24) & 0x000000FF; }
 
int UnpackByte2(int x) { return (x>>16) & 0x000000FF; }
 
int UnpackByte3(int x) { return (x>>8)  & 0x000000FF; }
 
int UnpackByte4(int x) { return (x>>0)  & 0x000000FF; }


// Pack signed 16-bit values. =========================================
 
int PackShorts(int a, int b)
{
	return ((a + 0x8000)<<16) | ((b + 0x8000) & 0x0000FFFF);
}
 
int UnpackShort1(int x) { return ((x>>16) & 0x0000FFFF) - 0x8000; }
 
int UnpackShort2(int x) { return ((x    ) & 0x0000FFFF) - 0x8000; }
// By FusedQyou
 
bool KeyBound (str key)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError(StrParam(s:"KeyBound called serverside with key = \"", s:key, s:"\", returning false"));
		return false;
	}
	return !StrEquals(StrParam(k:key), StrParam(s:"??? (", s:key, s:")"));
}

// By Monsterovich.

 
bool KeyUp(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((~buttons & key) == key) { return true; }
		return false;
}

 
bool KeyUpAny(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (~buttons & key) { return true; }
		return false;
}

 
bool PlayerKeyUp(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((~buttons & key) == key) { return true; }
		return false;
}

 
bool PlayerKeyUpAny(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if (~buttons & key) { return true; }
		return false;
}


 
bool KeyDown(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((buttons & key) == key) { return true; }
		return false;
}

 
bool KeyDownAny(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (buttons & key) { return true; }
		return false;
}

 
bool PlayerKeyDown(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((buttons & key) == key) { return true; }
		return false;
}

 
bool PlayerKeyDownAny(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if (buttons & key) { return true; }
		return false;
}


 
bool KeyPressed(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

 
bool KeyPressedAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if (newbuttons & key) { return true; }
		return false;
}

 
bool PlayerKeyPressed(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

 
bool PlayerKeyPressedAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if (newbuttons & key) { return true; }
		return false;
}


 
bool KeyReleased(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

 
bool KeyReleasedAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if (newbuttons & key) { return true; }
		return false;
}

 
bool PlayerKeyReleased(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

 
bool PlayerKeyReleasedAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if (newbuttons & key) { return true; }
		return false;
}


 
bool KeyToggled(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if ((newbuttons & key) == key) { return true; }
		return false;
}

 
bool KeyToggledAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if (newbuttons & key) { return true; }
		return false;
}

 
bool PlayerKeyToggled(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if ((newbuttons & key) == key) { return true; }
		return false;
}

 
bool PlayerKeyToggledAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if (newbuttons & key) { return true; }
		return false;
}
// Angles

 
fixed deg2ang(fixed degrees)
{
	return FixedDiv(degrees, 360.0);
}

 
fixed rad2ang(fixed radians)
{
	return FixedDiv(radians, TAU);
}

 
fixed ang2deg(fixed angle)
{
	return FixedMul(angle, 360.0);
}

 
fixed ang2rad(fixed angle)
{
	return FixedMul(angle, TAU);
}

 
fixed deg2rad(fixed degrees)
{
	return FixedDiv(degrees, 57.29577951308232);
}

 
fixed rad2deg(fixed radians)
{
	return FixedMul(radians, 57.29577951308232);
}

 
int ang2byte(fixed angle)
{
    return (int)(angle)>>8;
}

 
fixed byte2ang(int angle)
{
    return (fixed)(angle<<8);
}

// Gravity

 
fixed GetGravityG(void)
{
	int sv_gravity = GetCVar("sv_gravity");
	if (sv_gravity > SHORT_MAX || sv_gravity < SHORT_MIN)
		return IntDiv(sv_gravity, 800);
	return FixedDiv(a_GetCVarFixed("sv_gravity"), 800.0);
}

 
void SetGravityG(fixed gravity)
{
	SetGravity(FixedMul(gravity, 800.0));
}

 
fixed grav2accel(fixed grav)
{
	return FixedDiv(grav, 800.0);
}

 
fixed accel2grav(fixed accel)
{
	return FixedMul(accel, 800.0);
}

 
fixed height2jumpz(fixed height, fixed gravity)
{
	return FixedSqrt((fixed)(2 * (int)(FixedMul(height, gravity))));
}

 
fixed jumpz2height(fixed jumpz, fixed gravity)
{
	return (fixed)((int)(FixedDiv(FixedMul(jumpz, jumpz), gravity)) / 2);
}

internal enum : int { PARSENUMBER_SUCCESS = 0 };
internal enum : int { PARSENUMBER_OVERFLOW = 1 };
internal enum : int { PARSENUMBER_BADFORMAT = 2 };

 
int ACSUtils_CheckRadix(int radix, str functionName)
{
	if (radix <= 0)
	{
		ACSUtils_ProgramError(StrParam(s:functionName, s:": invalid radix ", d:radix, s:". Assuming base 10."));
		return 10;
	}
	else if (radix > 36)
	{
		ACSUtils_ProgramError(StrParam(s:functionName, s:" only supports bases up to 36 (10 digits + 26 letters), but was requested to parse base ", d:radix, s:". Assuming base 10."));
		return 10;
	}
	return radix;
}

 
void ACSUtils_ParseSign(str s, int i)
{
	if (GetChar(s, i) == '+')
	{
		r1 = 1;
		r2 = i + 1;
		return;
	}
	else if (GetChar(s, i) == '-')
	{
		r1 = -1;
		r2 = i + 1;
		return;
	}
	
	r1 = 1;
	r2 = i;
	return;
}
	
 
void ACSUtils_ParseBasePrefix(str s, int i)
{
	if (StrIEqualsAt(s, i, "0x"))
	{
		r1 = 16;
		r2 = i + 2;
		return;
	}
	else if (StrIEqualsAt(s, i, "0o"))
	{
		r1 = 8;
		r2 = i + 2;
		return;
	}
	else if (StrIEqualsAt(s, i, "0b"))
	{
		r1 = 2;
		r2 = i + 2;
		return;
	}
	
	r1 = 0;
	r2 = i;
	return;
}

 
int ACSUtils_ParseDigit(int c, int radix)
{
	int digit;
	if (c >= '0' && c <= '9')
		digit = c - '0';
	else if (c >= 'a' && c <= 'z')
		digit = c - 'a' + 10;
	else if (c >= 'A' && c <= 'Z')
		digit = c - 'A' + 10;
	else
		return -1;
		
	if (digit < radix)
		return digit;
	return -1;
}

 
void ParseInt(str s, int radix)
{
	int i = 0;
	int sign = 1;
	radix = ACSUtils_CheckRadix(radix, "ParseInt");
	
	ACSUtils_ParseSign(s, i);
	sign = r1;
	i = r2;

	ACSUtils_ParseBasePrefix(s, i);
	radix = condFalse(r1, radix);
	i = r2;
	
	int len = StrLen(s);
	if (i == len)
	{
		r1 = PARSENUMBER_BADFORMAT;
		r2 = 0;
	}	
	
	int maxresult = cond(sign > 0, INT_MAX, INT_MIN);
	int limit = abs(maxresult / radix);
	int result = 0;
	bool overflowed = false;
	for (; i < len; i++)
	{
		int c = GetChar(s, i);
		int digit = ACSUtils_ParseDigit(c, radix);
		if (digit < 0)
		{
			r1 = PARSENUMBER_BADFORMAT;
			r2 = 0;
			return;
		}
		
		if (limit >= abs(result) && result != INT_MIN)
			result = result * radix + sign * digit;
		else
			overflowed = true;			
	}
	
	if (overflowed)
	{
		r1 = PARSENUMBER_OVERFLOW;
		r2 = maxresult;
		return;
	}
	else
	{
		r1 = PARSENUMBER_SUCCESS;
		r2 = result;
		return;
	}
}
	
 
void ParseFixed(str s, int radix)
{
	int i = 0;
	int sign = 1;
	radix = ACSUtils_CheckRadix(radix, "ParseFixed");
	
	ACSUtils_ParseSign(s, i);
	sign = r1;
	i = r2;

	ACSUtils_ParseBasePrefix(s, i);
	radix = condFalse(r1, radix);
	i = r2;
	
	int len = StrLen(s);
	if (i == len)
	{
		r1 = PARSENUMBER_BADFORMAT;
		r2 = 0;
	}
	
	int maxresult = cond(sign > 0, INT_MAX, INT_MIN);
	int limit = abs(maxresult / radix);
	int result = 0;
	bool overflowed = false;
	bool hasfraction = false;
	int digit;
	for (; i < len; i++)
	{
		int c = GetChar(s, i);
		if (c == '.')
		{
			hasfraction = true;
			break;
		}
		
		digit = ACSUtils_ParseDigit(c, radix);
		if (digit < 0)
		{
			r1 = PARSENUMBER_BADFORMAT;
			r2 = 0;
			return;
		}
		
		if (limit >= abs(result) && result != INT_MIN)
			result = result * radix + sign * (digit<<16);
		else
			overflowed = true;			
	}
	
	if (hasfraction)
	{
		i++;
		
		int divisor = radix;
		for (; i < len; i++)
		{
			digit = ACSUtils_ParseDigit(GetChar(s, i), radix);
			if (digit < 0)
			{
				r1 = PARSENUMBER_BADFORMAT;
				r2 = 0;
				return;
			}
			
			if (divisor <= (radix<<16))
			{
				result = result + sign * (digit<<16) / divisor;
				if (sign < 0 && result > 0)
				{
					overflowed = true;
					break;
				}
				divisor *= radix;
			}
		}
	}			
	
	if (overflowed)
	{
		r1 = PARSENUMBER_OVERFLOW;
		r2 = maxresult;
		return;
	}
	else
	{
		r1 = PARSENUMBER_SUCCESS;
		r2 = result;
		return;
	}
}
	

 
int atoi(str s)
{
	ParseInt(s, 10);
	return r2;
}

 
fixed atof(str s)
{
	ParseFixed(s, 10);
	return r2;
}

 
bool StrIsInt(str s)
{
	ParseInt(s, 10);
	return r1 != PARSENUMBER_BADFORMAT;
}

 
bool StrIsFixed(str s)
{
	ParseFixed(s, 10);
	return r1 != PARSENUMBER_BADFORMAT;
}
// Actor property shorthands with network optimization.
// Idea from AOW.


/*
int Accuracy
fixed Alpha
bool Ambush
fixed AttackZOffset
bool ChaseGoal
int Damage
fixed DamageFactor
fixed DamageMultiplier
bool Dormant
bool Dropped
fixed Friction
bool Friendly
bool Frightened
fixed Gravity
int Health
fixed Height
bool Invulnerable
fixed JumpZ
int Mass
int MasterTID
fixed MaxDropOffHeight
fixed MaxStepHeight
fixed MeleeRange
bool NoTrigger
bool NoTarget
fixed Radius
int ReactionTime
int RenderStyle
fixed ScaleX
fixed ScaleY
int Score
int SpawnHealth
fixed Speed
int Stamina
int StencilColor
int TargetTID
int TracerTID
fixed ViewHeight
int Waterlevel
str DamageType
str Nametag
str Species
str ActiveSound
str AttackSound
str DeathSound
str PainSound
str SeeSound
*/

 
int GetActorAccuracy(int tid) { return GetActorProperty(tid, APROP_Accuracy); }
 
void SetActorAccuracy(int tid, int Accuracy)
{
	if (GetActorProperty(tid, APROP_Accuracy) != Accuracy)
		SetActorProperty(tid, APROP_Accuracy, Accuracy);
}

 
fixed GetActorAlpha(int tid) { return GetActorProperty(tid, APROP_Alpha); }
 
void SetActorAlpha(int tid, fixed Alpha)
{
	if (GetActorProperty(tid, APROP_Alpha) != Alpha)
		SetActorProperty(tid, APROP_Alpha, Alpha);
}

 
bool GetActorAmbush(int tid) { return GetActorProperty(tid, APROP_Ambush); }
 
void SetActorAmbush(int tid, bool Ambush)
{
	if (GetActorProperty(tid, APROP_Ambush) != Ambush)
		SetActorProperty(tid, APROP_Ambush, Ambush);
}

 
fixed GetActorAttackZOffset(int tid) { return GetActorProperty(tid, APROP_AttackZOffset); }
 
void SetActorAttackZOffset(int tid, fixed AttackZOffset)
{
	if (GetActorProperty(tid, APROP_AttackZOffset) != AttackZOffset)
		SetActorProperty(tid, APROP_AttackZOffset, AttackZOffset);
}

 
bool GetActorChaseGoal(int tid) { return GetActorProperty(tid, APROP_ChaseGoal); }
 
void SetActorChaseGoal(int tid, bool ChaseGoal)
{
	if (GetActorProperty(tid, APROP_ChaseGoal) != ChaseGoal)
		SetActorProperty(tid, APROP_ChaseGoal, ChaseGoal);
}

 
int GetActorDamage(int tid) { return GetActorProperty(tid, APROP_Damage); }
 
void SetActorDamage(int tid, int Damage)
{
	if (GetActorProperty(tid, APROP_Damage) != Damage)
		SetActorProperty(tid, APROP_Damage, Damage);
}

 
fixed GetActorDamageFactor(int tid) { return GetActorProperty(tid, APROP_DamageFactor); }
 
void SetActorDamageFactor(int tid, fixed DamageFactor)
{
	if (GetActorProperty(tid, APROP_DamageFactor) != DamageFactor)
		SetActorProperty(tid, APROP_DamageFactor, DamageFactor);
}

 
fixed GetActorDamageMultiplier(int tid) { return GetActorProperty(tid, APROP_DamageMultiplier); }
 
void SetActorDamageMultiplier(int tid, fixed DamageMultiplier)
{
	if (GetActorProperty(tid, APROP_DamageMultiplier) != DamageMultiplier)
		SetActorProperty(tid, APROP_DamageMultiplier, DamageMultiplier);
}

 
bool GetActorDormant(int tid) { return GetActorProperty(tid, APROP_Dormant); }
 
void SetActorDormant(int tid, bool Dormant)
{
	if (GetActorProperty(tid, APROP_Dormant) != Dormant)
		SetActorProperty(tid, APROP_Dormant, Dormant);
}

 
bool GetActorDropped(int tid) { return GetActorProperty(tid, APROP_Dropped); }
 
void SetActorDropped(int tid, bool Dropped)
{
	if (GetActorProperty(tid, APROP_Dropped) != Dropped)
		SetActorProperty(tid, APROP_Dropped, Dropped);
}

 
fixed GetActorFriction(int tid) { return GetActorProperty(tid, APROP_Friction); }
 
void SetActorFriction(int tid, fixed Friction)
{
	if (GetActorProperty(tid, APROP_Friction) != Friction)
		SetActorProperty(tid, APROP_Friction, Friction);
}

 
bool GetActorFriendly(int tid) { return GetActorProperty(tid, APROP_Friendly); }
 
void SetActorFriendly(int tid, bool Friendly)
{
	if (GetActorProperty(tid, APROP_Friendly) != Friendly)
		SetActorProperty(tid, APROP_Friendly, Friendly);
}

 
bool GetActorFrightened(int tid) { return GetActorProperty(tid, APROP_Frightened); }
 
void SetActorFrightened(int tid, bool Frightened)
{
	if (GetActorProperty(tid, APROP_Frightened) != Frightened)
		SetActorProperty(tid, APROP_Frightened, Frightened);
}

 
fixed GetActorGravity(int tid) { return GetActorProperty(tid, APROP_Gravity); }
 
void SetActorGravity(int tid, fixed Gravity)
{
	if (GetActorProperty(tid, APROP_Gravity) != Gravity)
		SetActorProperty(tid, APROP_Gravity, Gravity);
}

 
int GetActorHealth(int tid) { return GetActorProperty(tid, APROP_Health); }
 
void SetActorHealth(int tid, int Health)
{
	if (GetActorProperty(tid, APROP_Health) != Health)
		SetActorProperty(tid, APROP_Health, Health);
}

 
fixed GetActorHeight(int tid) { return GetActorProperty(tid, APROP_Height); }
 
void SetActorHeight(int tid, fixed Height)
{
	if (GetActorProperty(tid, APROP_Height) != Height)
		SetActorProperty(tid, APROP_Height, Height);
}

 
bool GetActorInvulnerable(int tid) { return GetActorProperty(tid, APROP_Invulnerable); }
 
void SetActorInvulnerable(int tid, bool Invulnerable)
{
	if (GetActorProperty(tid, APROP_Invulnerable) != Invulnerable)
		SetActorProperty(tid, APROP_Invulnerable, Invulnerable);
}

 
fixed GetActorJumpZ(int tid) { return GetActorProperty(tid, APROP_JumpZ); }
 
void SetActorJumpZ(int tid, fixed JumpZ)
{
	if (GetActorProperty(tid, APROP_JumpZ) != JumpZ)
		SetActorProperty(tid, APROP_JumpZ, JumpZ);
}

 
fixed GetActorMass(int tid) { return GetActorProperty(tid, APROP_Mass); }
 
void SetActorMass(int tid, fixed Mass)
{
	if (GetActorProperty(tid, APROP_Mass) != Mass)
		SetActorProperty(tid, APROP_Mass, Mass);
}

 
int GetActorMasterTID(int tid) { return GetActorProperty(tid, APROP_MasterTID); }
 
void SetActorMasterTID(int tid, int MasterTID)
{
	if (GetActorProperty(tid, APROP_MasterTID) != MasterTID)
		SetActorProperty(tid, APROP_MasterTID, MasterTID);
}

 
fixed GetActorMaxDropOffHeight(int tid) { return GetActorProperty(tid, APROP_MaxDropOffHeight); }
 
void SetActorMaxDropOffHeight(int tid, fixed MaxDropOffHeight)
{
	if (GetActorProperty(tid, APROP_MaxDropOffHeight) != MaxDropOffHeight)
		SetActorProperty(tid, APROP_MaxDropOffHeight, MaxDropOffHeight);
}

 
fixed GetActorMaxStepHeight(int tid) { return GetActorProperty(tid, APROP_MaxStepHeight); }
 
void SetActorMaxStepHeight(int tid, fixed MaxStepHeight)
{
	if (GetActorProperty(tid, APROP_MaxStepHeight) != MaxStepHeight)
		SetActorProperty(tid, APROP_MaxStepHeight, MaxStepHeight);
}

 
int GetActorMeleeRange(int tid) { return GetActorProperty(tid, APROP_MeleeRange); }
 
void SetActorMeleeRange(int tid, fixed MeleeRange)
{
	if (GetActorProperty(tid, APROP_MeleeRange) != MeleeRange)
		SetActorProperty(tid, APROP_MeleeRange, MeleeRange);
}

 
bool GetActorNoTrigger(int tid) { return GetActorProperty(tid, APROP_NoTrigger); }
 
void SetActorNoTrigger(int tid, bool NoTrigger)
{
	if (GetActorProperty(tid, APROP_NoTrigger) != NoTrigger)
		SetActorProperty(tid, APROP_NoTrigger, NoTrigger);
}

 
bool GetActorNoTarget(int tid) { return GetActorProperty(tid, APROP_NoTarget); }
 
void SetActorNoTarget(int tid, bool NoTarget)
{
	if (GetActorProperty(tid, APROP_NoTarget) != NoTarget)
		SetActorProperty(tid, APROP_NoTarget, NoTarget);
}

 
int GetActorRadius(int tid) { return GetActorProperty(tid, APROP_Radius); }
 
void SetActorRadius(int tid, fixed Radius)
{
	if (GetActorProperty(tid, APROP_Radius) != Radius)
		SetActorProperty(tid, APROP_Radius, Radius);
}

 
int GetActorReactionTime(int tid) { return GetActorProperty(tid, APROP_ReactionTime); }
 
void SetActorReactionTime(int tid, int ReactionTime)
{
	if (GetActorProperty(tid, APROP_ReactionTime) != ReactionTime)
		SetActorProperty(tid, APROP_ReactionTime, ReactionTime);
}

 
int GetActorRenderStyle(int tid) { return GetActorProperty(tid, APROP_RenderStyle); }
 
void SetActorRenderStyle(int tid, int RenderStyle)
{
	if (GetActorProperty(tid, APROP_RenderStyle) != RenderStyle)
		SetActorProperty(tid, APROP_RenderStyle, RenderStyle);
}

 
int GetActorScaleX(int tid) { return GetActorProperty(tid, APROP_ScaleX); }
 
void SetActorScaleX(int tid, fixed ScaleX)
{
	if (GetActorProperty(tid, APROP_ScaleX) != ScaleX)
		SetActorProperty(tid, APROP_ScaleX, ScaleX);
}

 
int GetActorScaleY(int tid) { return GetActorProperty(tid, APROP_ScaleY); }
 
void SetActorScaleY(int tid, fixed ScaleY)
{
	if (GetActorProperty(tid, APROP_ScaleY) != ScaleY)
		SetActorProperty(tid, APROP_ScaleY, ScaleY);
}

 
int GetActorScore(int tid) { return GetActorProperty(tid, APROP_Score); }
 
void SetActorScore(int tid, int Score)
{
	if (GetActorProperty(tid, APROP_Score) != Score)
		SetActorProperty(tid, APROP_Score, Score);
}

 
int GetActorSpawnHealth(int tid) { return GetActorProperty(tid, APROP_SpawnHealth); }
 
void SetActorSpawnHealth(int tid, int SpawnHealth)
{
	if (GetActorProperty(tid, APROP_SpawnHealth) != SpawnHealth)
		SetActorProperty(tid, APROP_SpawnHealth, SpawnHealth);
}

 
int GetActorSpeed(int tid) { return GetActorProperty(tid, APROP_Speed); }
 
void SetActorSpeed(int tid, fixed Speed)
{
	if (GetActorProperty(tid, APROP_Speed) != Speed)
		SetActorProperty(tid, APROP_Speed, Speed);
}

 
int GetActorStamina(int tid) { return GetActorProperty(tid, APROP_Stamina); }
 
void SetActorStamina(int tid, int Stamina)
{
	if (GetActorProperty(tid, APROP_Stamina) != Stamina)
		SetActorProperty(tid, APROP_Stamina, Stamina);
}

 
int GetActorStencilColor(int tid) { return GetActorProperty(tid, APROP_StencilColor); }
 
void SetActorStencilColor(int tid, int StencilColor)
{
	if (GetActorProperty(tid, APROP_StencilColor) != StencilColor)
		SetActorProperty(tid, APROP_StencilColor, StencilColor);
}

 
int GetActorTargetTID(int tid) { return GetActorProperty(tid, APROP_TargetTID); }
 
void SetActorTargetTID(int tid, int TargetTID)
{
	if (GetActorProperty(tid, APROP_TargetTID) != TargetTID)
		SetActorProperty(tid, APROP_TargetTID, TargetTID);
}

 
int GetActorTracerTID(int tid) { return GetActorProperty(tid, APROP_TracerTID); }
 
void SetActorTracerTID(int tid, int TracerTID)
{
	if (GetActorProperty(tid, APROP_TracerTID) != TracerTID)
		SetActorProperty(tid, APROP_TracerTID, TracerTID);
}

// GetActorViewHeight is native
 
void SetActorViewHeight(int tid, fixed ViewHeight)
{
	if (GetActorProperty(tid, APROP_ViewHeight) != ViewHeight)
		SetActorProperty(tid, APROP_ViewHeight, ViewHeight);
}

 
int GetActorWaterlevel(int tid) { return GetActorProperty(tid, APROP_Waterlevel); }
 
void SetActorWaterlevel(int tid, int Waterlevel)
{
	if (GetActorProperty(tid, APROP_Waterlevel) != Waterlevel)
		SetActorProperty(tid, APROP_Waterlevel, Waterlevel);
}

// String properties.
 
str GetActorDamageType(int tid) { return GetActorProperty(tid, APROP_DamageType); }
 
void SetActorDamageType(int tid, str DamageType)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_DamageType), DamageType))
		SetActorProperty(tid, APROP_DamageType, DamageType);
}

 
str GetActorNametag(int tid) { return GetActorProperty(tid, APROP_Nametag); }
 
void SetActorNametag(int tid, str Nametag)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_Nametag), Nametag))
		SetActorProperty(tid, APROP_Nametag, Nametag);
}

 
str GetActorSpecies(int tid) { return GetActorProperty(tid, APROP_Species); }
 
void SetActorSpecies(int tid, str Species)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_Species), Species))
		SetActorProperty(tid, APROP_Species, Species);
}

 
str GetActorActiveSound(int tid) { return GetActorProperty(tid, APROP_ActiveSound); }
 
void SetActorActiveSound(int tid, str ActiveSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_ActiveSound), ActiveSound))
		SetActorProperty(tid, APROP_ActiveSound, ActiveSound);
}

 
str GetActorAttackSound(int tid) { return GetActorProperty(tid, APROP_AttackSound); }
 
void SetActorAttackSound(int tid, str AttackSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_AttackSound), AttackSound))
		SetActorProperty(tid, APROP_AttackSound, AttackSound);
}

 
str GetActorDeathSound(int tid) { return GetActorProperty(tid, APROP_DeathSound); }
 
void SetActorDeathSound(int tid, str DeathSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_DeathSound), DeathSound))
		SetActorProperty(tid, APROP_DeathSound, DeathSound);
}

 
str GetActorPainSound(int tid) { return GetActorProperty(tid, APROP_PainSound); }
 
void SetActorPainSound(int tid, str PainSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_PainSound), PainSound))
		SetActorProperty(tid, APROP_PainSound, PainSound);
}

 
str GetActorSeeSound(int tid) { return GetActorProperty(tid, APROP_SeeSound); }
 
void SetActorSeeSound(int tid, str SeeSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_SeeSound), SeeSound))
		SetActorProperty(tid, APROP_SeeSound, SeeSound);
}


 
bool IsPlayer(void)
{
	return PlayerNumber() >= 0;
}

script "ACSUtils_ActorPlayerNumber" (int tid)
{
	SetActivator(tid);
	SetResultValue(PlayerNumber());
}

 
int ActorPlayerNumber(int tid)
{
	return ACS_NamedExecuteWithResult("ACSUtils_ActorPlayerNumber", tid);
}

// todo Verify works correctly with added cast.
 
bool ActorIsPlayer(int tid)
{
	return (bool)(ClassifyActor(tid) & ACTOR_PLAYER);
}

 
str PlayerName(int player)
{
	return StrParam(n:player + 1);
}

 
int GetPlayerTeam(int player)
{
	return GetPlayerInfo(player, PLAYERINFO_TEAM);
}

 
int TeamPlayerCount(int team)
{
	return GetTeamProperty(team, TPROP_NumPlayers);
}


// ConsolePlayer stuff
 
bool ConsolePlayerInGame(void)
{
	return PlayerInGame(ConsolePlayerNumber());
}

 
str ConsolePlayerName(void)
{
	return PlayerName(ConsolePlayerNumber());
}

 
int ConsolePlayerTeam(void)
{
	return GetPlayerTeam(ConsolePlayerNumber());
}

 
bool SetActivatorToConsolePlayer(void)
{
	return SetActivatorToPlayer2(ConsolePlayerNumber());
}


 
bool SetActivatorToPlayer2(int player)
{
	if (SetActivatorToPlayer(player))
		return true;
		
	if (player >= 0 && player < 8)
		return false;
		
	return SetActivator(0, AAPTR_PLAYER1<<player);
}


// PlayerIsBot is native

 
bool PlayerIsConnected(int player)
{
	return PlayerInGame(player) || PlayerIsSpectator(player);
}

 
bool PlayerIsDeadSpectator(int player)
{
	return PlayerIsSpectator(player) == 2;
}

// PlayerInGame is native

// PlayerIsSpectator is native


 
int BotCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsBot(i))
			count++;
	return count;
}

 
int ClientCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsConnected(i))
			count++;
	return count;
}

 
int DeadSpectatorCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsDeadSpectator(i))
			count++;
	return count;
}

// PlayerCount is native

 
int SpectatorCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsSpectator(i))
			count++;
	return count;
}


int ACSUtils_Players[MAX_PLAYERS];

 
int PickRandomBot(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsBot(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

 
int PickRandomClient(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsConnected(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

 
int PickRandomDeadSpectator(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsDeadSpectator(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

 
int PickRandomPlayer(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerInGame(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

 
int PickRandomSpectator(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsSpectator(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

 
int PickRandomTeamPlayer(int team)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerInGame(i) && GetPlayerTeam(i) == team)
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}


















	

 
fixed CursorX(void)
{
	return ACSUtils_Ints[35];
}

 
fixed CursorY(void)
{
	return ACSUtils_Ints[0];
}

 
fixed CursorDeltaX(void)
{
	if (ACSUtils_Ints[8])
		return CursorMotionX();
	return ACSUtils_Ints[35] - ACSUtils_Ints[16];
}
 
fixed CursorDeltaY(void)
{
	if (ACSUtils_Ints[43])
		return CursorMotionY();
	return ACSUtils_Ints[0] - ACSUtils_Ints[47];
}

 
fixed CursorMotionX(void)
{
	return ACSUtils_Ints[29];
}

 
fixed CursorMotionY(void)
{
	return ACSUtils_Ints[38];
}

 
void SetCursorSpeed(fixed speed)
{
	ACSUtils_Ints[31] = speed;
	ACSUtils_Ints[7] = speed;
}

 
void SetCursorSpeedX(fixed speed)
{
	ACSUtils_Ints[31] = speed;
}

 
void SetCursorSpeedY(fixed speed)
{
	ACSUtils_Ints[7] = speed;
}

 
void SetCursorPosition(fixed x, fixed y)
{
	ACSUtils_Ints[35] = x;
	ACSUtils_Ints[0] = y;
}

 
void CenterCursor(void)
{
	SetCursorPosition(ACSUtils_Ints[53] / 2, ACSUtils_Ints[2] / 2);
}

 
void EnableCursorWrap(bool enable)
{
	ACSUtils_Ints[8] = enable;
	ACSUtils_Ints[43] = enable;
}

 
void EnableCursorWrapX(bool enable)
{
	ACSUtils_Ints[8] = enable;
}

 
void EnableCursorWrapY(bool enable)
{
	ACSUtils_Ints[43] = enable;
}

 
void ACSUtils_ClampCursor(void)
{
	fixed width = ACSUtils_Ints[53];
	fixed height = ACSUtils_Ints[2];
	
	fixed borderX = HudBorderXFor(width);
	fixed borderY = HudBorderYFor(height);
	
	ACSUtils_Ints[35] += borderX;
	ACSUtils_Ints[0] += borderY;
	
	width +=  (fixed)((int)(borderX) * 2);
	height += (fixed)((int)(borderY) * 2);

	if (ACSUtils_Ints[8])
		ACSUtils_Ints[35] = mod(ACSUtils_Ints[35], width);
	else
		ACSUtils_Ints[35] = clamp(ACSUtils_Ints[35], 0, width);
	
	if (ACSUtils_Ints[43])
		ACSUtils_Ints[0] = mod(ACSUtils_Ints[0], height);
	else
		ACSUtils_Ints[0] = clamp(ACSUtils_Ints[0], 0, height);
		
	ACSUtils_Ints[35] -= borderX;
	ACSUtils_Ints[0] -= borderY;
}

 
void SetCursorArea(fixed width, fixed height)
{
	if (width <= 0.0)
		ACSUtils_ProgramError(StrParam(s:"Cursor area width set to ", f:width));
	if (height <= 0.0)
		ACSUtils_ProgramError(StrParam(s:"Cursor area height set to ", f:height));
	
	ACSUtils_Ints[35] = FixedMul(ACSUtils_Ints[35], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[0] = FixedMul(ACSUtils_Ints[0], FixedDiv(height, ACSUtils_Ints[2]));
	ACSUtils_Ints[16] = FixedMul(ACSUtils_Ints[16], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[47] = FixedMul(ACSUtils_Ints[47], FixedDiv(height, ACSUtils_Ints[2]));
	ACSUtils_Ints[29] = FixedMul(ACSUtils_Ints[29], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[38] = FixedMul(ACSUtils_Ints[38], FixedDiv(height, ACSUtils_Ints[2]));

	ACSUtils_Ints[53] = width;
	ACSUtils_Ints[2] = height;
}

 
void UpdateCursor(void)
{
	ACSUtils_Ints[16] = ACSUtils_Ints[35];
	ACSUtils_Ints[47] = ACSUtils_Ints[0];

	fixed sensitivity = a_GetCVarFixed("mouse_sensitivity");
	fixed speedX = FixedDiv(ACSUtils_Ints[31], FixedMul(a_GetCVarFixed("m_yaw"), sensitivity));
	fixed speedY = FixedDiv(ACSUtils_Ints[7], FixedMul(a_GetCVarFixed("m_pitch"), sensitivity));
	
	speedX = (fixed)((int)(FixedMul((fixed)((int)(speedX) * 2), ACSUtils_Ints[53])) / 64000);
	speedY = (fixed)((int)(FixedMul((fixed)((int)(speedY) * 2), ACSUtils_Ints[2])) / 32000);

	fixed dx = (fixed)(-GetPlayerInput(ConsolePlayerNumber(), INPUT_YAW)   * (int)(speedX));
    fixed dy = (fixed)(-GetPlayerInput(ConsolePlayerNumber(), INPUT_PITCH) * (int)(speedY));

	if (GetCVar("invertmouse"))
        dy = -dy;
		
	ACSUtils_Ints[29] = dx;
	ACSUtils_Ints[38] = dy;
	ACSUtils_Ints[35] += dx;
	ACSUtils_Ints[0] += dy;
	ACSUtils_ClampCursor();
}

internal enum : int { PORT_ZDOOM = 1 };
internal enum : int { PORT_GZDOOM = 2 };
internal enum : int { PORT_ZANDRONUM = 3 };



// Port identification methods copied from ACS-X
 
int IdentifySourcePort(void)
{
	if (ACSUtils_Ints[4] != -1)
		return ACSUtils_Ints[4];

	// todo Verify this statement still works with the added cast.
	if (bool(GetPlayerAccountName(0)))
	{
		// GetPlayerAccountName returns a string (possibly empty) in Zandronum
		// but 0 in GZDoom.
		ACSUtils_Ints[4] = PORT_ZANDRONUM;
		return ACSUtils_Ints[4];
	}
	
	int tid = UniqueTid();
	if (SpawnForced("DynamicLight", 0.0, 0.0, 0.0, tid))
	{
		// DynamicLight is a built-in actor in GZDoom.
		Thing_Remove(tid);
		ACSUtils_Ints[4] = PORT_GZDOOM;
		return ACSUtils_Ints[4];
	}
	
	ACSUtils_Ints[4] = PORT_ZDOOM;
	return ACSUtils_Ints[4];
}

 
str GetPortName(void)
{
	int port = IdentifySourcePort();
	switch (port)
	{
	case PORT_ZDOOM:
		return "ZDoom";
	case PORT_GZDOOM:
		return "GZDoom";
	case PORT_ZANDRONUM:
		return "Zandronum";
	}

	return StrParam(s:"IdentifySourcePort() returned ", d:port);
}

 
bool IsZandronum(void)
{
	return IdentifySourcePort() == PORT_ZANDRONUM;
}

 
bool IsGZDoom(void)
{
	int port = IdentifySourcePort();
	return port == PORT_GZDOOM || port == PORT_ZANDRONUM;
}

 
bool IsServer(void)
{
	if (ConsolePlayerNumber() < 0)
		return true;
		
	// Needs to be done like this to avoid crashing the script in ZDoom.
	if (IsZandronum())
		return !IsNetworkGame();
	
	return true;
}

 
bool IsClient(void)
{
	return ConsolePlayerNumber() >= 0;
}

 
bool IsServerOnly(void)
{
	return IsServer() && !IsClient();
}

 
bool IsClientOnly(void)
{
	return IsClient() && !IsServer();
}

 
bool IsOpenGL(void)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError("IsOpenGL() used serverside. Assuming OpenGL renderer.");
		return true; // OpenGL generally has less limitations.
	}
	
	// Correctly identifies ZDoom with a config file from GZDoom with vid_renderer = 1.
	if (IsGZDoom())
		return GetCVar("vid_renderer") == 1 && GetCVar("gl_nogl") == 0;
	
	return false;
}

// Most of this file is written by carlcyber and bagheadspidey.
// See http://forum.zdoom.org/viewtopic.php?f=3&t=35383
// Interface 

// BCC type
internal enum : fixed { ASPECT_4_3 = (fixed)((int)(4.0) / 3) };
internal enum : fixed { ASPECT_5_4 = 1.25 };
internal enum : fixed { ASPECT_16_9 = (fixed)((int)(16.0) / 9) };
internal enum : fixed { ASPECT_16_10 = 1.6 };
internal enum : fixed { ASPECT_17_10 = 1.7 };

 
fixed GetAspectRatio(void)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError("GetAspectRatio() called serverside. Assuming 4:3.");
		return ASPECT_4_3;
	}

	raw width = GetCVar("vid_defwidth");
	raw height = GetCVar("vid_defheight");
	raw nowidescreen = GetCVar("vid_nowidescreen");
	raw tft = GetCVar("vid_tft");
	raw aspect = GetCVar("vid_aspect");
	switch(aspect)
	{
		case 1:	return ASPECT_16_9;
		case 2:	return ASPECT_16_10;
		case 3:	return ASPECT_4_3;
		case 4:	return ASPECT_5_4;
		case 5: return ASPECT_17_10;
	}
	if(nowidescreen)
	{
		if(!tft)
			return ASPECT_4_3;
		if(height * ASPECT_5_4 == width<<16)
			return ASPECT_5_4;
		else
			return ASPECT_4_3;
	}
	if(abs((abs(height * ASPECT_16_9)>>16) - width) < 10)
	{
		return ASPECT_16_9;
	}
	if(abs((abs(height * ASPECT_17_10)>>16) - width) < 10)
	{
		return ASPECT_17_10;
	}
	if(abs((abs(height * ASPECT_16_10)>>16) - width) < 60)
	{
		if((width == 320 && height == 200) || (width == 640 && height == 400))
			return ASPECT_4_3;
		return ASPECT_16_10;
	}
	if((height * ASPECT_5_4)>>16 == width && tft)
	{
		return ASPECT_5_4;
	}
	return ASPECT_4_3;
}

/*
 * Gets the borders of the specified HUD size.
 * [NOTE]:
 *     1. The HUD borders are written in HudLeft, HudRight, HudTop, and HudBottom variables.
 *     2. Status bar and small screen blocks (screenblocks < 11) are not supported.
 * [Credit]
 *    Original HUD edge positioning functions by bagheadspidey
 */

 
fixed HudBorderXFor(fixed width)
{
	fixed ar = GetAspectRatio();
	switch (ar)
	{
		case ASPECT_4_3: return 0.0;
		case ASPECT_16_9: return (fixed)((int)(width) / 6);
		case ASPECT_16_10: return (fixed)((int)(width) / 10);
		case ASPECT_17_10: return (fixed)((int)(width) / 80);
	}
	return 0.0;
}

 
fixed HudBorderYFor(fixed height)
{
	if (GetAspectRatio() == ASPECT_5_4)
		return (fixed)((int)(height) / 30);
	return 0.0;
}

 
fixed HudLeftFor(fixed width)
{
	return -HudBorderXFor(width);
}
 
fixed HudX1For(fixed width)
{
	return -HudBorderXFor(width);
}

 
fixed HudRightFor(fixed width)
{
	return width + HudBorderXFor(width);
}
 
fixed HudX2For(fixed width)
{
	return width + HudBorderXFor(width);
}


 
fixed HudTopFor(fixed height)
{
	return -HudBorderYFor(height);
}
 
fixed HudY1For(fixed height)
{
	return -HudBorderYFor(height);
}

 
fixed HudBottomFor(fixed height)
{
	return height + HudBorderYFor(height);
}
 
fixed HudY2For(fixed height)
{
	return height + HudBorderYFor(height);
}

// Contributed to ACSUtils by Konda

// Sorts an array, given the named scripts for comparing and swapping array elements
void SortArray(int begin_index, int end_index, str less_than, str cb_swap)
{
    ACSUtils_heap_sort(begin_index, end_index - 1, less_than, cb_swap);
    //_selection_sort(begin_index, end_index - 1, less_than, cb_swap);
}

/*
void _selection_sort(int begin, int end, str lt, str cb_swap)
{
    for(int i = begin; i <= end-1; i++)
    for(int j = i+1; j <= end; j++)
        if(ACS_NamedExecuteWithResult(lt, j, i))
            ACS_NamedExecuteWithResult(cb_swap, j, i);
}
*/

void ACSUtils_heap_sort(int begin, int end, str lt, str cb_swap)
{
    if(begin >= end) return;
    int heap_size;
    
    // Since the supplied comparison is a min function, we build a max heap to finally cb_swap the max with the last element in the array range
    ACSUtils_build_max_heap(begin, end, lt, cb_swap);
    
    // At this point in execution the heap size will be >= 2
    do
    {
        // Protip: use ExecuteWithResult even when ur not expecting a result, otherwise the execution order will be fucked up if a script is called from inside a (i almost ragequit acs again until i figured this out)
        //Log(s:"Imma cb_swap yo momma");
        ACS_NamedExecuteWithResult(cb_swap, begin, end);
        heap_size = --end - begin + 1;
        
        // There's only a single violation of the max-heap property - at the root of the entire heap, from now on
        ACSUtils_max_heapify(begin, begin, end, lt, cb_swap);
    }
    while(heap_size > 1);
}

// Reorders the entire array range to establish the max-heap invariant
void ACSUtils_build_max_heap(int begin, int end, str lt, str cb_swap)
{
    // i = n/2 downto 1 inclusive, for arrays whose indexing is in range 1..n
    for(int i = begin + (end - begin) / 2; i >= begin; i--)
        ACSUtils_max_heapify(i, begin, end, lt, cb_swap);
}

// Corrects a single violation of the max-heap property at the given index, continuing to one of its subtrees after correction
void ACSUtils_max_heapify(int index, int begin, int end, str lt, str cb_swap)
{
    // Implemented as 2 functions to avoid recursion, just in case of some acs shitrestriction
    do
    {
        index = ACSUtils_max_heapify_step(index, begin, end, lt, cb_swap);
    }
    while(index != -1);
}

// Returns index of the next subtree to be checked for the max-heap property and corrected; Returns -1 when done
int ACSUtils_max_heapify_step(int index, int begin, int end, str lt, str cb_swap)
{
    int lchild = ACSUtils_heap_lchild(index, begin);
    int rchild = ACSUtils_heap_rchild(index, begin);
    
    // Check the max-heap property for the subtree rooted at _index_
    int max_i = index;
    if((lchild <= end) && ACS_NamedExecuteWithResult(lt, max_i, lchild))
        max_i = lchild;
    if((rchild <= end) && ACS_NamedExecuteWithResult(lt, max_i, rchild))
        max_i = rchild;
    if(max_i != index)
    {
        ACS_NamedExecuteWithResult(cb_swap, index, max_i);
        return max_i;
    }
    return -1;
}

// Heap node children index functions
int ACSUtils_heap_lchild(int index, int begin)
{
    return begin + 2*(index - begin);
}

int ACSUtils_heap_rchild(int index, int begin)
{
    return begin + 2*(index - begin) + 1;
}

// Contributed to ACSUtils by Konda

 
void ShuffleArray(int begin, int end, str cb_swap)
{
	end--;
    for(int pick = begin; pick < end; pick++)
    {
        int index = random(pick, end);
        if(index != pick)
            ACS_NamedExecuteWithResult(cb_swap, pick, index);
    }
}

 
void SyncVariable(int tid, raw value)
{
	if (ClassifyActor(tid) == ACTOR_NONE)
	{
		if (!SpawnForced("ACSUtils_Sync", 0.0, 0.0, 0.0, tid))	
		{
			ACSUtils_ProgramError(StrParam
			(
				s:"Failed to spawn sync actor for tid ", d:tid, s:". ",
				s:"Make sure you copied \cjdecorate.acsutils \c-to your project."
			));
		}
	}
					
	SetActorProperty(tid, APROP_SPEED, value);
}

 
raw GetSyncVar(int tid)
{
	return GetActorProperty(tid, APROP_SPEED);
}

 
raw GetSyncVarDefault(int tid, raw default_value)
{
	if (ClassifyActor(tid) == ACTOR_NONE)
		return default_value;
	return GetActorProperty(tid, APROP_SPEED);
}

// When adding new properties, don't forget to edit ACSUTILS_HUDSTATE_SIZE.
internal enum : int { ACSUTILS_HUDLIB_SAVEDSTATES = 16 };
internal enum : int { ACSUTILS_HUDSTATE_SIZE = 39 };
internal enum : int { ACSUTILS_HUDLIB_STACKSIZE = ACSUTILS_HUDSTATE_SIZE * ACSUTILS_HUDLIB_SAVEDSTATES };



















































	

	



	
	





 
void HudResetState(void)
{
	ACSUtils_Ints[52] = false;


	ACSUtils_Ints[19] = 0.0;
	ACSUtils_Ints[9] = 0.0;
	ACSUtils_Ints[40] = 0.0;
	ACSUtils_Ints[28] = 0.0;
	ACSUtils_Ints[11] = 0.0;

	ACSUtils_Ints[32] = 0.0;
	ACSUtils_Ints[15] = 0.0;
	ACSUtils_Ints[20] = 0.0;

	ACSUtils_Ints[12] = 0.0;
	ACSUtils_Ints[21] = 0.0;

	ACSUtils_Ints[42] = true;
	ACSUtils_Ints[17] = HUD_PROJECTION_AUTO;

	ACSUtils_Ints[23] = 640.0;
	ACSUtils_Ints[46] = 480.0;
	ACSUtils_Ints[45] = false;

	ACSUtils_Ints[41] = 0.0;
	ACSUtils_Ints[18] = 0.0;

	ACSUtils_Ints[30] = 1.0;
	ACSUtils_Ints[51] = 1.0;

	ACSUtils_Ints[37] = false;

	ACSUtils_Ints[5] = 0.0;
	ACSUtils_Ints[6] = HUD_STAYTIME_FOREVER;
	ACSUtils_Ints[48] = 0.0;

	ACSUtils_Ints[39] = HUD_BLENDSTYLE_NORMAL;
	ACSUtils_Ints[25] = 1.0;

	ACSUtils_Ints[24] = true;
	ACSUtils_Ints[50] = true;
	ACSUtils_Ints[34] = true;

	ACSUtils_Ints[27] = HUDMSG_LAYER_OVERHUD;

	ACSUtils_Ints[13] = HUD_ALIGN_CENTER;
	ACSUtils_Ints[49] = HUD_ALIGN_CENTER;
	ACSUtils_Ints[26] = false;
	ACSUtils_Strings[0] = "SMALLFONT";
	ACSUtils_Ints[1] = false;
	ACSUtils_Ints[3] = CR_UNTRANSLATED;
	ACSUtils_Ints[54] = false;
	ACSUtils_Ints[33] = false;
	ACSUtils_Ints[10] = false;
}

raw HudStateStack[ACSUTILS_HUDLIB_STACKSIZE];

 
void HudClearStateStack(void)
{
	ACSUtils_Ints[36] = 0;
}

 
void HudPushState(void)
{
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[52];


	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[19];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[9];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[40];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[28];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[11];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[32];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[15];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[20];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[12];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[21];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[42];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[17];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[23];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[46];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[45];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[41];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[18];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[30];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[51];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[37];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[5];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[6];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[48];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[39];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[25];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[24];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[50];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[34];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[27];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[13];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[49];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[26];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Strings[0];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[1];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[3];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[54];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[33];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[10];
	
	if (ACSUtils_Ints[36] > ACSUTILS_HUDLIB_STACKSIZE)
		ACSUtils_LimitError("HudPushState(): state stack overflow.");
}

 
void HudPopState(void)
{
	if (ACSUtils_Ints[36] == 0)
	{
		ACSUtils_ProgramError("HudPopState() called with no saved state.");
		return;
	}

	ACSUtils_Ints[10] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[33] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[54] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[3] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[1] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Strings[0] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[26] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[49] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[13] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[27] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[34] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[50] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[24] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[25] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[39] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[48] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[6] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[5] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[37] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[51] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[30] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[18] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[41] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[45] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[46] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[23] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[17] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[42] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[21] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[12] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[20] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[15] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[32] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[11] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[28] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[40] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[9] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[19] = HudStateStack[--ACSUtils_Ints[36]];


	ACSUtils_Ints[52] = HudStateStack[--ACSUtils_Ints[36]];
	
	if (ACSUtils_Ints[36] < 0)
		ACSUtils_ProgramError("HudPushState/HudPopState are bugged. Report this bug to the acsutils project.");
}

 
void HudSetCameraPosition(fixed x, fixed y, fixed z)
{
	ACSUtils_Ints[19] = x;
	ACSUtils_Ints[9] = y;
	ACSUtils_Ints[40] = z;
}

 
void HudSetCameraAngles(fixed angle, fixed pitch)
{
	ACSUtils_Ints[28] = angle;
	ACSUtils_Ints[11] = pitch;
}

 
void HudSetCameraVector(fixed x, fixed y, fixed z)
{
	VectorToAngles(x, y, z);
	ACSUtils_Ints[28] = r1;
	ACSUtils_Ints[11] = r2;
}


internal enum : int { HUD_CAMERAACTOR_NOPOSITION = 1 };
internal enum : int { HUD_CAMERAACTOR_NOPREDICTION = 2 };
internal enum : int { HUD_CAMERAACTOR_NODIRECTION = 4 };
internal enum : int { HUD_CAMERAACTOR_NOVIEWHEIGHT = 8 };

 
void HudSetCameraActorAdvanced(int tid, int flags)
{
	if (!(flags & HUD_CAMERAACTOR_NOPOSITION))
	{
		fixed x = GetActorX(tid);
		fixed y = GetActorY(tid);
		fixed z = GetActorZ(tid);
		
		if (!(flags & HUD_CAMERAACTOR_NOVIEWHEIGHT))
			z += GetActorViewHeight(tid);
		
		if (!(flags & HUD_CAMERAACTOR_NOPREDICTION))
		{
			x -= GetActorVelX(tid);
			y -= GetActorVelY(tid);
			z -= GetActorVelZ(tid);
		}	
		
		HudSetCameraPosition(x, y, z);
	}
	
	if (!(flags & HUD_CAMERAACTOR_NODIRECTION))
		HudSetCameraAngles(GetActorAngle(tid), -GetActorPitch(tid));
}

 
void HudSetCameraActor(int tid)
{
	HudSetCameraActorAdvanced(tid, 0);
}

 
void HudSetPoint3D(fixed x, fixed y, fixed z)
{
	ACSUtils_Ints[52] = true;
	ACSUtils_Ints[32] = x;
	ACSUtils_Ints[15] = y;
	ACSUtils_Ints[20] = z;
}

 
void HudSet2DOffset(fixed x, fixed y)
{
	ACSUtils_Ints[12] = x;
	ACSUtils_Ints[21] = y;
}

 
void HudSetAutoDistanceScale(bool autoDistanceScale)
{
	ACSUtils_Ints[42] = autoDistanceScale;
}

 
void HudSetProjectionMode(int mode)
{
	ACSUtils_Ints[17] = mode;
}

 
void HudSetVirtualSize(fixed width, fixed height)
{
	ACSUtils_Ints[23] = width;
	ACSUtils_Ints[46] = height;
}

 
void HudUseDefaultSize(void)
{
	ACSUtils_Ints[23] = 640.0;
	ACSUtils_Ints[46] = 480.0;
}

 
void HudUseRealSize(void)
{
	ACSUtils_Ints[23] = (fixed)(GetScreenWidth()<<16);
	ACSUtils_Ints[46] = (fixed)(GetScreenHeight()<<16);
}

 
fixed HudBorderX(void)
{
	return HudBorderXFor(ACSUtils_Ints[23]);
}

 
fixed HudBorderY(void)
{
	return HudBorderXFor(ACSUtils_Ints[46]);
}

 
fixed HudLeft(void)
{
	return HudLeftFor(ACSUtils_Ints[23]);
}
 
fixed HudX1(void)
{
	return HudX1For(ACSUtils_Ints[23]);
}

 
fixed HudRight(void)
{
	return HudRightFor(ACSUtils_Ints[23]);
}
 
fixed HudX2(void)
{
	return HudX2For(ACSUtils_Ints[23]);
}

 
fixed HudTop(void)
{
	return HudTopFor(ACSUtils_Ints[46]);
}
 
fixed HudY1(void)
{
	return HudY1For(ACSUtils_Ints[46]);
}

 
fixed HudBottom(void)
{
	return HudBottomFor(ACSUtils_Ints[46]);
}
 
fixed HudY2(void)
{
	return HudY2For(ACSUtils_Ints[46]);
}

 
void HudSetExcludeStatusBar(bool exclude)
{
	ACSUtils_Ints[45] = exclude;
}

 
void HudSetPoint(fixed x, fixed y)
{
	ACSUtils_Ints[52] = false;
	ACSUtils_Ints[41] = x;
	ACSUtils_Ints[18] = y;
}

 
void HudSetScaleXY(fixed scaleX, fixed scaleY)
{
	if (scaleX != 0.0)
		ACSUtils_Ints[30] = FixedDiv(1.0, scaleX);
	else
		ACSUtils_Ints[30] = 0.0;
	
	if (scaleY != 0.0)
		ACSUtils_Ints[51] = FixedDiv(1.0, scaleY);
	else
		ACSUtils_Ints[51] = 0.0;
}

 
void HudSetScale(fixed scale)
{
	HudSetScaleXY(scale, scale);
}

 
void HudSetInvScale(fixed invScale)
{
	ACSUtils_Ints[30] = invScale;
	ACSUtils_Ints[51] = invScale;
}

 
void HudSetInvScaleXY(fixed invScaleX, fixed invScaleY)
{
	ACSUtils_Ints[30] = invScaleX;
	ACSUtils_Ints[51] = invScaleY;
}

 
void HudSetShowToEveryone(bool showToEveryone)
{
	ACSUtils_Ints[37] = showToEveryone;
}

 
void HudSetAppearTime(fixed appearTime)
{
	ACSUtils_Ints[5] = appearTime;
}

 
void HudSetStayTime(fixed stayTime)
{
	ACSUtils_Ints[6] = stayTime;
}

 
void HudSetDisappearTime(fixed disappearTime)
{
	ACSUtils_Ints[48] = disappearTime;
}

 
void HudSetBlendStyle(int style)
{
	ACSUtils_Ints[39] = style;
}

 
void HudSetAlpha(fixed alpha)
{
	ACSUtils_Ints[25] = alpha;
}

 
void HudSetShowIn3DView(bool show)
{
	ACSUtils_Ints[24] = show;
}

 
void HudSetShowOnFullAutomap(bool show)
{
	ACSUtils_Ints[50] = show;
}

 
void HudSetShowOnOverlayAutomap(bool show)
{
	ACSUtils_Ints[34] = show;
}

 
void HudSetLayer(int layer)
{
	ACSUtils_Ints[27] = layer;
}

 
void HudSetFont(str font)
{
	ACSUtils_Strings[0] = font;
}

 
void HudSetTextColor(int textColor)
{
	ACSUtils_Ints[1] = false;
	ACSUtils_Ints[3] = textColor;
}

 
void HudSetTextColorString(str textColor)
{
	ACSUtils_Ints[1] = true;
	ACSUtils_Ints[3] = textColor;
}

 
void HudSetCenterText(bool centerText)
{
	ACSUtils_Ints[26] = centerText;
}

 
void HudSetAlignment(int alignX, int alignY)
{
	ACSUtils_Ints[13] = alignX;
	ACSUtils_Ints[49] = alignY;
}

 
void HudSetAlign(fixed alignX, fixed alignY)
{
	ACSUtils_Ints[13] = alignX;
	ACSUtils_Ints[49] = alignY;
}

 
void HudSetAlignmentX(fixed alignX)
{
	ACSUtils_Ints[13] = alignX;
}

 
void HudSetAlignX(fixed alignX)
{
	ACSUtils_Ints[13] = alignX;
}

 
void HudSetAlignmentY(fixed alignY)
{
	ACSUtils_Ints[49] = alignY;
}

 
void HudSetAlignY(fixed alignY)
{
	ACSUtils_Ints[49] = alignY;
}

 
void HudSetTextTypeOn(bool textTypeOn)
{
	ACSUtils_Ints[54] = textTypeOn;
}

 
void HudSetLogMessage(bool logMessage)
{
	ACSUtils_Ints[33] = logMessage;
}

 
void HudSetWordWrap(bool wordWrap)
{
	ACSUtils_Ints[10] = wordWrap;
}

//int ACSUtils_Ints[14];
//int ACSUtils_Ints[44];
//int ACSUtils_Ints[22];

 
bool ACSUtils_IsYShearing(void)
{
	if (ACSUtils_Ints[17] == HUD_PROJECTION_AUTO)
		return !IsOpenGL();
	
	return ACSUtils_Ints[17] == HUD_PROJECTION_YSHEARING;
}

// Rotate 3D point to view coordinate system.
 
void ACSUtils_HudRotate3DPoint(void)
{
	// Translated point coordinates.
	fixed x = ACSUtils_Ints[32] - ACSUtils_Ints[19];
	fixed y = ACSUtils_Ints[15] - ACSUtils_Ints[9];
	fixed z = ACSUtils_Ints[20] - ACSUtils_Ints[40];

	fixed rx, ry, rz;
	fixed s, c;

	// Rotate around Z axis.
	s = sin(-ACSUtils_Ints[28]);
	c = cos(-ACSUtils_Ints[28]);
	rx = FixedMul(x, c) - FixedMul(y, s);
	ry = FixedMul(x, s) + FixedMul(y, c);
	x = rx; y = ry;

	// Rotate around Y axis.
	if (!ACSUtils_IsYShearing())
	{
		s = sin(-ACSUtils_Ints[11]);
		c = cos(-ACSUtils_Ints[11]);
		rx = FixedMul(x, c) - FixedMul(z, s);
		rz = FixedMul(x, s) + FixedMul(z, c);
		x = rx; z = rz;
	}

	ACSUtils_Ints[14] = x;
	ACSUtils_Ints[44] = y;
	ACSUtils_Ints[22] = z;
}

 
int HudGetDistance(void)
{
	ACSUtils_HudRotate3DPoint();
	return ACSUtils_Ints[14];
}


internal enum : int { CAMERA_BASE_DISTANCE = 128 };

 
void ACSUtils_HudDrawHudMessage(int id, int type, str text, bool isText)
{
	if (ACSUtils_Ints[30] == 0 || ACSUtils_Ints[51] == 0)
		return;

	type |= ACSUtils_Ints[27];
	if (!ACSUtils_Ints[24])
		type |= HUDMSG_NOTWITH3DVIEW;
	if (!ACSUtils_Ints[50])
		type |= HUDMSG_NOTWITHFULLMAP;
	if (!ACSUtils_Ints[34])
		type |= HUDMSG_NOTWITHOVERLAYMAP;
	
	if (ACSUtils_Ints[39] == HUD_BLENDSTYLE_ADDITIVE)
		type |= HUDMSG_ADDBLEND;
	else if (ACSUtils_Ints[25] != 1.0)
		type |= HUDMSG_ALPHA;

	fixed x = ACSUtils_Ints[41];
	fixed y = ACSUtils_Ints[18];
	fixed iScaleX = ACSUtils_Ints[30];
	fixed iScaleY = ACSUtils_Ints[51];
	
	if (ACSUtils_Ints[52])
	{
		ACSUtils_HudRotate3DPoint();

		// Check if point is behind the camera.
		if (ACSUtils_Ints[14] <= 0)
		{
			ClearHudMessage(id);
			return;
		}
			
		// I don't know what this factor means, but it fixes positioning bugs.
		fixed yFactor = 1.6;
		if (StatusBarVisible())
			yFactor = 1.9;

		// Half heights.
		fixed hw = (fixed)((int)(ACSUtils_Ints[23]) / 2);
		fixed hh = (fixed)((int)(ACSUtils_Ints[46]) / 2);

		// Project point.
		x = -FixedDiv(ACSUtils_Ints[44], ACSUtils_Ints[14]);
		y = -FixedDiv(ACSUtils_Ints[22], ACSUtils_Ints[14]);
		
		if (ACSUtils_IsYShearing())
			y += tan(ACSUtils_Ints[11]);
		
		// Postprocess projected point.
		x += ACSUtils_Ints[12] + hw + FixedMul(hw, x);
		y += ACSUtils_Ints[21] + hh + FixedMul(FixedMul(hh, yFactor), y);
		
		if (ACSUtils_Ints[42])
		{
			iScaleX = FixedMul(iScaleX, ACSUtils_Ints[14] / CAMERA_BASE_DISTANCE);
			iScaleY = FixedMul(iScaleY, ACSUtils_Ints[14] / CAMERA_BASE_DISTANCE);
		}
	}
	
	fixed w = FixedMul(ACSUtils_Ints[23], iScaleX);
	fixed h = FixedMul(ACSUtils_Ints[46], iScaleY);
	SetHudSize(itrunc(w), itrunc(h), !(ACSUtils_Ints[52] || ACSUtils_Ints[45]));
	
	x = trunc(FixedMul(x, iScaleX));
	y = trunc(FixedMul(y, iScaleY));
	
	if (ACSUtils_Ints[13] == HUD_ALIGN_LEFT)
		x += 0.1;
	else if (ACSUtils_Ints[13] == HUD_ALIGN_RIGHT)
		x += 0.2;
		
	if (ACSUtils_Ints[49] == HUD_ALIGN_TOP)
		y += 0.1;
	else if (ACSUtils_Ints[49] == HUD_ALIGN_BOTTOM)
		y += 0.2;
		
	if (ACSUtils_Ints[26])
		x += 0.4;
	
	// BUG: this really simplifies the code, but the messages will only stay
	// for 9 hours.
	fixed stayTime = ACSUtils_Ints[6];
	if (stayTime < 0.0)
		stayTime = FIXED_MAX;
	
	if (ACSUtils_Ints[37])
	{
		HudMessageBold(s:text;
			type,
			id,
			ACSUtils_Ints[3],
			x, y,
			stayTime, ACSUtils_Ints[5], ACSUtils_Ints[48],
			ACSUtils_Ints[25]
		);
	}
	else
	{
		HudMessage(s:text;
			type,
			id,
			ACSUtils_Ints[3],
			x, y,
			stayTime, ACSUtils_Ints[5], ACSUtils_Ints[48],
			ACSUtils_Ints[25]
		);
	}
}

 
void HudDrawText(int id, str text)
{
	int type = HUDMSG_FADEINOUT;
	if (ACSUtils_Ints[5] > 0 && ACSUtils_Ints[54])
		type = HUDMSG_TYPEON;
	
	if (ACSUtils_Ints[33])
		type |= HUDMSG_LOG;
	if (ACSUtils_Ints[1])
		type |= HUDMSG_COLORSTRING;
	if (!ACSUtils_Ints[10])
		type |= HUDMSG_NOWRAP;

	SetFont(ACSUtils_Strings[0]);
	ACSUtils_HudDrawHudMessage(id, type, text, true);
}

 
void HudDrawImage(int id, str image)
{
	SetFont(image);
	ACSUtils_HudDrawHudMessage(id, HUDMSG_FADEINOUT, "A", false);
}

} // strict namespace BCSUtils
