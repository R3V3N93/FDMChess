#nocompact
#pragma raw include on
#library "chess"
#import "zcommon.bcs"

#include "lib/bcsutils.acs"
#import "lib/log.g.acs"

#include "game/class/pawn.acs"
#include "game/class/king.acs"
#include "game/class/bishop.acs"

#include "game/game.acs"
#include "game/class.acs"
#include "game/player.acs"
#include "game/map.acs"

strict namespace {

enum : int
{
	EVAL_BAR_HEIGHT = 1216,
	EVAL_BAR_FLOOR = 439,
};

enum : fixed
{
    WHITE_SPAWN_PIVOT_X = -512.0,
    WHITE_SPAWN_PIVOT_Y = 640.0,
    BLACK_SPAWN_PIVOT_X = -512.0,
    BLACK_SPAWN_PIVOT_Y = 1152.0
};

script "main" OPEN
{
    //SetMusic("CHESSTB");
    SetMusicVolume(0.1);

    If (GetCurrentGameMode() != "TEAMGAME")
	{
	    SetCurrentGameMode("TEAMGAME");
	}

    for(int i = 0; i < 2; i++)
    {
        for(int j = 1; j <= 6; j++)
        {
            CHESS::MAP::SetSelectionValue(i, j, 1, CHESS::game.classCountMax[j]);
        }
    }

    // Sets up the chessboard camera.
	SetActorPitch(1, 0.25);
	SetCameraToTexture(1, "ZTRIGGER", 90);
    // This for selection screen.
    SetActorPitch(2, 0.25);

    CHESS::setGameState(CHESS::GAMESTATE_PICKCLASS);
    CHESS::SetTimer(CHESS::TIMER_PREP);

    while(CHESS::game.timer > 0)
    {
        delay(1);
    }

    LogDebug(__SCRIPT__ + " : Starting the game thrusting players from board and giving losers remainders");

    for(int i = 0; i < BCSUTILS::MAX_PLAYERS; i++)
    {
        if(players[i].ingame)
        {
            SetActivatorToPlayer(i);
            if(players[i].class == CHESS::CLASS::CLASS_EMPTY)
            {  
                CHESS::CLASS::becomeClass(CHESS::GetRemainingClass(), true);
                CHESS::MAP::TeleportToChessBoard();
            }
            CHESS::MAP::ThrustPlayerFromChessBoard(i);
            SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
        }
    }

    SetMusic("DMCCHESS");
    SetMusicVolume(0.3);

    BCSUtils::ClearHudMessageBold(1);

    SetActivatorToPlayer(-1);
    LogDebug(__SCRIPT__ + " : Done!");
    CHESS::SetGameState(CHESS::GAMESTATE_OPENING);
    CHESS::SetTimer(CHESS::TIMER_INGAME);

    while(1) 
    {
        /////////////////////////////////////
        // Evaluation bar
        /////////////////////////////////////
        fixed evalBarRatio = fixed(CHESS::game.score[CHESS::TEAM_WHITE] + 1) / fixed(CHESS::game.score[0] + CHESS::game.score[1] + 2);
        int evalBarHeight = int(evalBarRatio * fixed(EVAL_BAR_HEIGHT)) + EVAL_BAR_FLOOR;
        //log(d:evalBarHeight);
        Floor_MoveToValue(10000, 128, evalBarHeight, 0);

        /////////////////////////////////////
        // Score indicator
        /////////////////////////////////////
        void scoreIndicator(int team)  // Nested function is really cool!
        {
            int score = CHESS::getScore(team);

            int digit3 = score / 100;
            int digit2 = (score - digit3 * 100) / 10;
            int digit1 = score - digit3 * 100 - digit2 * 10;
            // Line tag 456 are black, and 123 are for white
            // and yeah... CHESS::TEAM_BLACK is 1
            // This is going to be crazy to interpret without these comments
            SetLineTexture(1 + team * 3, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"CALNUM", d:digit3));
            SetLineTexture(2 + team * 3, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"CALNUM", d:digit2));
            SetLineTexture(3 + team * 3, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"CALNUM", d:digit1));
        }

        void TimerFormat()  // Nested function is really cool!
        {
            int time = CHESS::game.timer;

            int minute = time / 60;
            int second = time % 60;

            int second_first = second / 10;
            int second_second = second % 10; // second of second of second

            SetLineTexture(7, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"BALNUM", d:minute));
            SetLineTexture(8, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"BALNUM", d:second_first));
            SetLineTexture(9, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"BALNUM", d:second_second));
        }

        scoreIndicator(CHESS::TEAM_WHITE);
        scoreIndicator(CHESS::TEAM_BLACK);
        TimerFormat();

        if(CHESS::getScore(CHESS::TEAM_WHITE) > CHESS::MAP::CONST_FRAG_POINT_LIMIT || CHESS::getScore(CHESS::TEAM_BLACK) > CHESS::MAP::CONST_FRAG_POINT_LIMIT || CHESS::game.timer <= 0)
            break;

        delay(1);
    }
    CHESS::SetGameState(CHESS::GAMESTATE_CHECKMATE);
    int winner = 123;

    CHESS::StopTimer();
    SetMusic("");
    
    if(CHESS::getScore(CHESS::TEAM_WHITE) > CHESS::getScore(CHESS::TEAM_BLACK))
        winner = CHESS::TEAM_WHITE;
    else if (CHESS::getScore(CHESS::TEAM_WHITE) < CHESS::getScore(CHESS::TEAM_BLACK))
        winner = CHESS::TEAM_BLACk;

    LogDebug("Team " + str(winner) + " Won");

    CHESS::SetGameState(CHESS::GAMESTATE_CHECKMATE);

    AmbientSound("chess_game_end", 2);

    SetFont("CHRESULT");
    SetHUDSize(960, 720, false);
    HudMessageBold(s:"A";HUDMSG_PLAIN, -1, CR_UNTRANSLATED, 480.0, 360.0, 0.0);

    SetFont("CW_FONT2");
    SetHUDSize(2880, 2160, false);
    HudMessageBold(s:(winner == 123 ? "Stalemate" : (winner == CHESS::TEAM_WHITE ? "\cyWhite \c-Won!" : "\cgBlack \c-Won!"));HUDMSG_PLAIN, 1, CR_UNTRANSLATED, 1440.4, 520.0, 0.0);
    HudMessageBold(s:(winner == 123 ? "by Equal Frags" : (CHESS::game.timer == 0 ? "by Time Limit" : "by Frag Limit"));HUDMSG_PLAIN, 2, CR_UNTRANSLATED, 1440.4, 622.0, 0.0);
    SetHUDSize(1440, 1080, false);
    HudMessageBold(s:str(CHESS::getScore(CHESS::TEAM_WHITE)) + " \cjV\cuS " + str(CHESS::getScore(CHESS::TEAM_BLACK));HUDMSG_PLAIN, 3, CR_UNTRANSLATED, 720.0, 540.0, 0.0);
    Delay(35 * 5);
    ACS_NamedExecute("NextRound_Map",0);
}

} // strict namespace {}

Script "EndChess" (void) NET
{
    CHESS::game.timer = 0;
}

script "Script_Blood" (int bloodz, int headshotalws) // blood's Z is already passed automatically
{}